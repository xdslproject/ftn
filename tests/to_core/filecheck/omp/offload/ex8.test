// RUN: xftn %S/../../../../../examples/omp/offload/ex8.F90 --stdout -t %S/tmp --cleanup --offload -v0 | FileCheck %s 
//CHECK:       builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.ident = "flang version 20.1.7 (https://github.com/llvm/llvm-project 6146a88f60492b520a36f8f8f3231e15f3cc6082)", llvm.target_triple = "x86_64-unknown-linux-gnu", omp.is_gpu = false, omp.is_target_device = false, omp.requires = #omp<clause_requires none>, omp.target_triples = [], omp.version = #omp<version <version = 11>>} {
//CHECK-NEXT:    func.func @_QMex8_testPcalc() {
//CHECK-NEXT:      %0 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %1 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %2 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %3 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %4 = arith.constant 100 : index
//CHECK-NEXT:      %5 = memref.alloc(%4) : memref<?xf32>
//CHECK-NEXT:      memref.store %5, %0[] : memref<memref<?xf32>>
//CHECK-NEXT:      %6 = arith.constant 100 : index
//CHECK-NEXT:      %7 = memref.alloc(%6) : memref<?xf32>
//CHECK-NEXT:      memref.store %7, %1[] : memref<memref<?xf32>>
//CHECK-NEXT:      %8 = arith.constant 100 : index
//CHECK-NEXT:      %9 = memref.alloc(%8) : memref<?xf32>
//CHECK-NEXT:      memref.store %9, %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %10 = "memref.extract_aligned_pointer_as_index"(%2) : (memref<memref<?xf32>>) -> index
//CHECK-NEXT:      %11 = arith.index_cast %10 : index to i64
//CHECK-NEXT:      %12 = "llvm.inttoptr"(%11) : (i64) -> !llvm.ptr
//CHECK-NEXT:      %13 = arith.constant 0 : index
//CHECK-NEXT:      %14 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %15 = arith.constant 0 : index
//CHECK-NEXT:      %16 = arith.constant 1 : index
//CHECK-NEXT:      %17 = arith.constant 1 : index
//CHECK-NEXT:      %18 = "memref.dim"(%14, %15) : (memref<?xf32>, index) -> index
//CHECK-NEXT:      %19 = arith.constant 1 : index
//CHECK-NEXT:      %20 = arith.subi %18, %19 : index
//CHECK-NEXT:      %21 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %22 = arith.constant 0 : index
//CHECK-NEXT:      %23 = arith.constant 1 : index
//CHECK-NEXT:      %24 = arith.constant 1 : index
//CHECK-NEXT:      %25 = "memref.dim"(%21, %22) : (memref<?xf32>, index) -> index
//CHECK-NEXT:      %26 = "omp.map.bounds"(%13, %20, %18, %17, %23) <{stride_in_bytes = true, operandSegmentSizes = array<i32: 1, 1, 1, 1, 1>}> : (index, index, index, index, index) -> !omp.map_bounds_ty
//CHECK-NEXT:      %27 = "omp.map.info"(%2, %12, %26) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 0 : ui64, name = "", partial_map = false, var_type = f32, operandSegmentSizes = array<i32: 1, 1, 0, 1>}> : (memref<memref<?xf32>>, !llvm.ptr, !omp.map_bounds_ty) -> memref<memref<?xf32>>
//CHECK-NEXT{LITERAL}:      %28 = "omp.map.info"(%2, %27) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 1 : ui64, members_index = [[0 : i64]], name = "c", partial_map = false, var_type = memref<?xf32>, operandSegmentSizes = array<i32: 1, 0, 1, 0>}> : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> memref<memref<?xf32>>
//CHECK-NEXT:      "omp.target_enter_data"(%28, %27) <{operandSegmentSizes = array<i32: 0, 0, 0, 2>}> : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> ()
//CHECK-NEXT:      %29 = "memref.extract_aligned_pointer_as_index"(%0) : (memref<memref<?xf32>>) -> index
//CHECK-NEXT:      %30 = arith.index_cast %29 : index to i64
//CHECK-NEXT:      %31 = "llvm.inttoptr"(%30) : (i64) -> !llvm.ptr
//CHECK-NEXT:      %32 = arith.constant 0 : index
//CHECK-NEXT:      %33 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:      %34 = arith.constant 0 : index
//CHECK-NEXT:      %35 = arith.constant 1 : index
//CHECK-NEXT:      %36 = arith.constant 1 : index
//CHECK-NEXT:      %37 = "memref.dim"(%33, %34) : (memref<?xf32>, index) -> index
//CHECK-NEXT:      %38 = arith.constant 1 : index
//CHECK-NEXT:      %39 = arith.subi %37, %38 : index
//CHECK-NEXT:      %40 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:      %41 = arith.constant 0 : index
//CHECK-NEXT:      %42 = arith.constant 1 : index
//CHECK-NEXT:      %43 = arith.constant 1 : index
//CHECK-NEXT:      %44 = "memref.dim"(%40, %41) : (memref<?xf32>, index) -> index
//CHECK-NEXT:      %45 = "omp.map.bounds"(%32, %39, %37, %36, %42) <{stride_in_bytes = true, operandSegmentSizes = array<i32: 1, 1, 1, 1, 1>}> : (index, index, index, index, index) -> !omp.map_bounds_ty
//CHECK-NEXT:      %46 = "omp.map.info"(%0, %31, %45) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 1 : ui64, name = "", partial_map = false, var_type = f32, operandSegmentSizes = array<i32: 1, 1, 0, 1>}> : (memref<memref<?xf32>>, !llvm.ptr, !omp.map_bounds_ty) -> memref<memref<?xf32>>
//CHECK-NEXT{LITERAL}:      %47 = "omp.map.info"(%0, %46) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 1 : ui64, members_index = [[0 : i64]], name = "a", partial_map = false, var_type = memref<?xf32>, operandSegmentSizes = array<i32: 1, 0, 1, 0>}> : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> memref<memref<?xf32>>
//CHECK-NEXT:      %48 = "memref.extract_aligned_pointer_as_index"(%1) : (memref<memref<?xf32>>) -> index
//CHECK-NEXT:      %49 = arith.index_cast %48 : index to i64
//CHECK-NEXT:      %50 = "llvm.inttoptr"(%49) : (i64) -> !llvm.ptr
//CHECK-NEXT:      %51 = arith.constant 0 : index
//CHECK-NEXT:      %52 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:      %53 = arith.constant 0 : index
//CHECK-NEXT:      %54 = arith.constant 1 : index
//CHECK-NEXT:      %55 = arith.constant 1 : index
//CHECK-NEXT:      %56 = "memref.dim"(%52, %53) : (memref<?xf32>, index) -> index
//CHECK-NEXT:      %57 = arith.constant 1 : index
//CHECK-NEXT:      %58 = arith.subi %56, %57 : index
//CHECK-NEXT:      %59 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:      %60 = arith.constant 0 : index
//CHECK-NEXT:      %61 = arith.constant 1 : index
//CHECK-NEXT:      %62 = arith.constant 1 : index
//CHECK-NEXT:      %63 = "memref.dim"(%59, %60) : (memref<?xf32>, index) -> index
//CHECK-NEXT:      %64 = "omp.map.bounds"(%51, %58, %56, %55, %61) <{stride_in_bytes = true, operandSegmentSizes = array<i32: 1, 1, 1, 1, 1>}> : (index, index, index, index, index) -> !omp.map_bounds_ty
//CHECK-NEXT:      %65 = "omp.map.info"(%1, %50, %64) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 1 : ui64, name = "", partial_map = false, var_type = f32, operandSegmentSizes = array<i32: 1, 1, 0, 1>}> : (memref<memref<?xf32>>, !llvm.ptr, !omp.map_bounds_ty) -> memref<memref<?xf32>>
//CHECK-NEXT{LITERAL}:      %66 = "omp.map.info"(%1, %65) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 1 : ui64, members_index = [[0 : i64]], name = "b", partial_map = false, var_type = memref<?xf32>, operandSegmentSizes = array<i32: 1, 0, 1, 0>}> : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> memref<memref<?xf32>>
//CHECK-NEXT:      %67 = "omp.map.info"(%3) <{map_capture_type = #omp<variable_capture_kind (ByCopy)>, map_type = 512 : ui64, name = "i", partial_map = false, var_type = i32, operandSegmentSizes = array<i32: 1, 0, 0, 0>}> : (memref<i32>) -> memref<i32>
//CHECK-NEXT:      %68 = "memref.extract_aligned_pointer_as_index"(%2) : (memref<memref<?xf32>>) -> index
//CHECK-NEXT:      %69 = arith.index_cast %68 : index to i64
//CHECK-NEXT:      %70 = "llvm.inttoptr"(%69) : (i64) -> !llvm.ptr
//CHECK-NEXT:      %71 = arith.constant 0 : index
//CHECK-NEXT:      %72 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %73 = arith.constant 0 : index
//CHECK-NEXT:      %74 = arith.constant 1 : index
//CHECK-NEXT:      %75 = arith.constant 1 : index
//CHECK-NEXT:      %76 = "memref.dim"(%72, %73) : (memref<?xf32>, index) -> index
//CHECK-NEXT:      %77 = arith.constant 1 : index
//CHECK-NEXT:      %78 = arith.subi %76, %77 : index
//CHECK-NEXT:      %79 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %80 = arith.constant 0 : index
//CHECK-NEXT:      %81 = arith.constant 1 : index
//CHECK-NEXT:      %82 = arith.constant 1 : index
//CHECK-NEXT:      %83 = "memref.dim"(%79, %80) : (memref<?xf32>, index) -> index
//CHECK-NEXT:      %84 = "omp.map.bounds"(%71, %78, %76, %75, %81) <{stride_in_bytes = true, operandSegmentSizes = array<i32: 1, 1, 1, 1, 1>}> : (index, index, index, index, index) -> !omp.map_bounds_ty
//CHECK-NEXT:      %85 = "omp.map.info"(%2, %70, %84) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 515 : ui64, name = "", partial_map = false, var_type = f32, operandSegmentSizes = array<i32: 1, 1, 0, 1>}> : (memref<memref<?xf32>>, !llvm.ptr, !omp.map_bounds_ty) -> memref<memref<?xf32>>
//CHECK-NEXT{LITERAL}:      %86 = "omp.map.info"(%2, %85) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 513 : ui64, members_index = [[0 : i64]], name = "c", partial_map = false, var_type = memref<?xf32>, operandSegmentSizes = array<i32: 1, 0, 1, 0>}> : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> memref<memref<?xf32>>
//CHECK-NEXT:      "omp.target"(%47, %66, %67, %86, %46, %65, %85) <{operandSegmentSizes = array<i32: 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0>}> ({
//CHECK-NEXT:      ^0(%87 : memref<memref<?xf32>>, %88 : memref<memref<?xf32>>, %89 : memref<i32>, %90 : memref<memref<?xf32>>, %91 : memref<memref<?xf32>>, %92 : memref<memref<?xf32>>, %93 : memref<memref<?xf32>>):
//CHECK-NEXT:        %94 = arith.constant 1 : i32
//CHECK-NEXT:        %95 = arith.index_cast %94 : i32 to index
//CHECK-NEXT:        %96 = arith.constant 100 : i32
//CHECK-NEXT:        %97 = arith.index_cast %96 : i32 to index
//CHECK-NEXT:        %98 = arith.constant 1 : index
//CHECK-NEXT:        %99 = arith.index_cast %95 : index to i32
//CHECK-NEXT:        %100 = arith.constant 1 : index
//CHECK-NEXT:        %101 = arith.addi %97, %100 : index
//CHECK-NEXT:        %102 = scf.for %103 = %95 to %101 step %98 iter_args(%104 = %99) -> (i32) {
//CHECK-NEXT:          memref.store %104, %89[] : memref<i32>
//CHECK-NEXT:          %105 = memref.load %89[] : memref<i32>
//CHECK-NEXT:          %106 = arith.extui %105 : i32 to i64
//CHECK-NEXT:          %107 = arith.index_cast %106 : i64 to index
//CHECK-NEXT:          %108 = arith.constant 1 : index
//CHECK-NEXT:          %109 = arith.subi %107, %108 : index
//CHECK-NEXT:          %110 = memref.load %87[] : memref<memref<?xf32>>
//CHECK-NEXT:          %111 = memref.load %110[%109] : memref<?xf32>
//CHECK-NEXT:          %112 = memref.load %89[] : memref<i32>
//CHECK-NEXT:          %113 = arith.extui %112 : i32 to i64
//CHECK-NEXT:          %114 = arith.index_cast %113 : i64 to index
//CHECK-NEXT:          %115 = arith.constant 1 : index
//CHECK-NEXT:          %116 = arith.subi %114, %115 : index
//CHECK-NEXT:          %117 = memref.load %88[] : memref<memref<?xf32>>
//CHECK-NEXT:          %118 = memref.load %117[%116] : memref<?xf32>
//CHECK-NEXT:          %119 = arith.addf %111, %118 fastmath<contract> : f32
//CHECK-NEXT:          %120 = memref.load %89[] : memref<i32>
//CHECK-NEXT:          %121 = arith.extui %120 : i32 to i64
//CHECK-NEXT:          %122 = arith.index_cast %121 : i64 to index
//CHECK-NEXT:          %123 = arith.constant 1 : index
//CHECK-NEXT:          %124 = arith.subi %122, %123 : index
//CHECK-NEXT:          %125 = memref.load %90[] : memref<memref<?xf32>>
//CHECK-NEXT:          memref.store %119, %125[%124] : memref<?xf32>
//CHECK-NEXT:          %126 = arith.addi %103, %98 : index
//CHECK-NEXT:          %127 = memref.load %89[] : memref<i32>
//CHECK-NEXT:          %128 = arith.index_cast %98 : index to i32
//CHECK-NEXT:          %129 = arith.addi %127, %128 : i32
//CHECK-NEXT:          scf.yield %129 : i32
//CHECK-NEXT:        }
//CHECK-NEXT:        memref.store %102, %89[] : memref<i32>
//CHECK-NEXT:        "omp.terminator"() : () -> ()
//CHECK-NEXT:      }) : (memref<memref<?xf32>>, memref<memref<?xf32>>, memref<i32>, memref<memref<?xf32>>, memref<memref<?xf32>>, memref<memref<?xf32>>, memref<memref<?xf32>>) -> ()
//CHECK-NEXT:      %87 = "memref.extract_aligned_pointer_as_index"(%2) : (memref<memref<?xf32>>) -> index
//CHECK-NEXT:      %88 = arith.index_cast %87 : index to i64
//CHECK-NEXT:      %89 = "llvm.inttoptr"(%88) : (i64) -> !llvm.ptr
//CHECK-NEXT:      %90 = arith.constant 0 : index
//CHECK-NEXT:      %91 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %92 = arith.constant 0 : index
//CHECK-NEXT:      %93 = arith.constant 1 : index
//CHECK-NEXT:      %94 = arith.constant 1 : index
//CHECK-NEXT:      %95 = "memref.dim"(%91, %92) : (memref<?xf32>, index) -> index
//CHECK-NEXT:      %96 = arith.constant 1 : index
//CHECK-NEXT:      %97 = arith.subi %95, %96 : index
//CHECK-NEXT:      %98 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %99 = arith.constant 0 : index
//CHECK-NEXT:      %100 = arith.constant 1 : index
//CHECK-NEXT:      %101 = arith.constant 1 : index
//CHECK-NEXT:      %102 = "memref.dim"(%98, %99) : (memref<?xf32>, index) -> index
//CHECK-NEXT:      %103 = "omp.map.bounds"(%90, %97, %95, %94, %100) <{stride_in_bytes = true, operandSegmentSizes = array<i32: 1, 1, 1, 1, 1>}> : (index, index, index, index, index) -> !omp.map_bounds_ty
//CHECK-NEXT:      %104 = "omp.map.info"(%2, %89, %103) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 2 : ui64, name = "", partial_map = false, var_type = f32, operandSegmentSizes = array<i32: 1, 1, 0, 1>}> : (memref<memref<?xf32>>, !llvm.ptr, !omp.map_bounds_ty) -> memref<memref<?xf32>>
//CHECK-NEXT{LITERAL}:      %105 = "omp.map.info"(%2, %104) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 2 : ui64, members_index = [[0 : i64]], name = "c", partial_map = false, var_type = memref<?xf32>, operandSegmentSizes = array<i32: 1, 0, 1, 0>}> : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> memref<memref<?xf32>>
//CHECK-NEXT:      "omp.target_exit_data"(%105, %104) <{operandSegmentSizes = array<i32: 0, 0, 0, 2>}> : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> ()
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QQmain() {
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        func.call @_QMex8_testPcalc() : () -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    "llvm.mlir.global"() <{global_type = !llvm.array<{{[0-9]+}} x i8>, sym_name = "_{{.*}}", linkage = #llvm.linkage<"internal">, addr_space = 0 : i32, constant, value = "{{.*}}", unnamed_addr = 0 : i64}> ({
//CHECK-NEXT:    }) : () -> ()
//CHECK-NEXT:    func.func private @_FortranAProgramStart(i32, !llvm.ptr, !llvm.ptr, !llvm.ptr) -> () 
//CHECK-NEXT:    func.func private @_FortranAProgramEndStatement() -> () 
//CHECK-NEXT:    func.func @main(%0 : i32, %1 : !llvm.ptr, %2 : !llvm.ptr) -> i32 {
//CHECK-NEXT:      %3 = memref.alloc() : memref<1xmemref<memref<1xmemref<i8>>>>
//CHECK-NEXT:      %4 = arith.constant 0 : index
//CHECK-NEXT:      %5 = memref.load %3[%4] : memref<1xmemref<memref<1xmemref<i8>>>>
//CHECK-NEXT:      %6 = "memref.extract_aligned_pointer_as_index"(%5) : (memref<memref<1xmemref<i8>>>) -> index
//CHECK-NEXT:      %7 = arith.index_cast %6 : index to i64
//CHECK-NEXT:      %8 = "llvm.inttoptr"(%7) : (i64) -> !llvm.ptr
//CHECK-NEXT:      func.call @_FortranAProgramStart(%0, %1, %2, %8) : (i32, !llvm.ptr, !llvm.ptr, !llvm.ptr) -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        func.call @_QQmain() : () -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      func.call @_FortranAProgramEndStatement() : () -> ()
//CHECK-NEXT:      %9 = arith.constant 0 : i32
//CHECK-NEXT:      func.return %9 : i32
//CHECK-NEXT:    }
//CHECK-NEXT:  }
//CHECK-EMPTY:  
