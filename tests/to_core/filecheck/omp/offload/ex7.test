// RUN: xftn %S/../../../../../examples/omp/offload/ex7.F90 --stdout -t %S/tmp --cleanup --offload -v0 | FileCheck %s 
//CHECK:       builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.ident = "flang version 20.1.7 (https://github.com/llvm/llvm-project 6146a88f60492b520a36f8f8f3231e15f3cc6082)", llvm.target_triple = "x86_64-unknown-linux-gnu", omp.is_gpu = false, omp.is_target_device = false, omp.requires = #omp<clause_requires none>, omp.target_triples = [], omp.version = #omp<version <version = 11>>} {
//CHECK-NEXT:    func.func @_QMex7_testPcalc() {
//CHECK-NEXT:      %0 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %1 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %2 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %3 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %4 = arith.constant 100 : index
//CHECK-NEXT:      %5 = memref.alloc(%4) : memref<?xf32>
//CHECK-NEXT:      memref.store %5, %0[] : memref<memref<?xf32>>
//CHECK-NEXT:      %6 = arith.constant 100 : index
//CHECK-NEXT:      %7 = memref.alloc(%6) : memref<?xf32>
//CHECK-NEXT:      memref.store %7, %1[] : memref<memref<?xf32>>
//CHECK-NEXT:      %8 = arith.constant 100 : index
//CHECK-NEXT:      %9 = memref.alloc(%8) : memref<?xf32>
//CHECK-NEXT:      memref.store %9, %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %10 = "memref.extract_aligned_pointer_as_index"(%2) : (memref<memref<?xf32>>) -> index
//CHECK-NEXT:      %11 = arith.index_cast %10 : index to i64
//CHECK-NEXT:      %12 = "llvm.inttoptr"(%11) : (i64) -> !llvm.ptr
//CHECK-NEXT:      %13 = arith.constant 0 : index
//CHECK-NEXT:      %14 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %15 = arith.constant 0 : index
//CHECK-NEXT:      %16 = arith.constant 1 : index
//CHECK-NEXT:      %17 = arith.constant 1 : index
//CHECK-NEXT:      %18 = "memref.dim"(%14, %15) : (memref<?xf32>, index) -> index
//CHECK-NEXT:      %19 = arith.constant 1 : index
//CHECK-NEXT:      %20 = arith.subi %18, %19 : index
//CHECK-NEXT:      %21 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %22 = arith.constant 0 : index
//CHECK-NEXT:      %23 = arith.constant 1 : index
//CHECK-NEXT:      %24 = arith.constant 1 : index
//CHECK-NEXT:      %25 = "memref.dim"(%21, %22) : (memref<?xf32>, index) -> index
//CHECK-NEXT:      %26 = "omp.map.bounds"(%13, %20, %18, %17, %23) <{stride_in_bytes = true, operandSegmentSizes = array<i32: 1, 1, 1, 1, 1>}> : (index, index, index, index, index) -> !omp.map_bounds_ty
//CHECK-NEXT:      %27 = "omp.map.info"(%2, %12, %26) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 2 : ui64, name = "", partial_map = false, var_type = f32, operandSegmentSizes = array<i32: 1, 1, 0, 1>}> : (memref<memref<?xf32>>, !llvm.ptr, !omp.map_bounds_ty) -> memref<memref<?xf32>>
//CHECK-NEXT{LITERAL}:      %28 = "omp.map.info"(%2, %27) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 1 : ui64, members_index = [[0 : i64]], name = "c", partial_map = false, var_type = memref<?xf32>, operandSegmentSizes = array<i32: 1, 0, 1, 0>}> : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> memref<memref<?xf32>>
//CHECK-NEXT:      "omp.target_data"(%28, %27) <{operandSegmentSizes = array<i32: 0, 0, 2, 0, 0>}> ({
//CHECK-NEXT:      ^0(%29 : memref<memref<?xf32>>, %30 : memref<memref<?xf32>>):
//CHECK-NEXT:        %31 = "memref.extract_aligned_pointer_as_index"(%0) : (memref<memref<?xf32>>) -> index
//CHECK-NEXT:        %32 = arith.index_cast %31 : index to i64
//CHECK-NEXT:        %33 = "llvm.inttoptr"(%32) : (i64) -> !llvm.ptr
//CHECK-NEXT:        %34 = arith.constant 0 : index
//CHECK-NEXT:        %35 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:        %36 = arith.constant 0 : index
//CHECK-NEXT:        %37 = arith.constant 1 : index
//CHECK-NEXT:        %38 = arith.constant 1 : index
//CHECK-NEXT:        %39 = "memref.dim"(%35, %36) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %40 = arith.constant 1 : index
//CHECK-NEXT:        %41 = arith.subi %39, %40 : index
//CHECK-NEXT:        %42 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:        %43 = arith.constant 0 : index
//CHECK-NEXT:        %44 = arith.constant 1 : index
//CHECK-NEXT:        %45 = arith.constant 1 : index
//CHECK-NEXT:        %46 = "memref.dim"(%42, %43) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %47 = "omp.map.bounds"(%34, %41, %39, %38, %44) <{stride_in_bytes = true, operandSegmentSizes = array<i32: 1, 1, 1, 1, 1>}> : (index, index, index, index, index) -> !omp.map_bounds_ty
//CHECK-NEXT:        %48 = "omp.map.info"(%0, %33, %47) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 1 : ui64, name = "", partial_map = false, var_type = f32, operandSegmentSizes = array<i32: 1, 1, 0, 1>}> : (memref<memref<?xf32>>, !llvm.ptr, !omp.map_bounds_ty) -> memref<memref<?xf32>>
//CHECK-NEXT{LITERAL}:        %49 = "omp.map.info"(%0, %48) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 1 : ui64, members_index = [[0 : i64]], name = "a", partial_map = false, var_type = memref<?xf32>, operandSegmentSizes = array<i32: 1, 0, 1, 0>}> : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> memref<memref<?xf32>>
//CHECK-NEXT:        %50 = "memref.extract_aligned_pointer_as_index"(%1) : (memref<memref<?xf32>>) -> index
//CHECK-NEXT:        %51 = arith.index_cast %50 : index to i64
//CHECK-NEXT:        %52 = "llvm.inttoptr"(%51) : (i64) -> !llvm.ptr
//CHECK-NEXT:        %53 = arith.constant 0 : index
//CHECK-NEXT:        %54 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:        %55 = arith.constant 0 : index
//CHECK-NEXT:        %56 = arith.constant 1 : index
//CHECK-NEXT:        %57 = arith.constant 1 : index
//CHECK-NEXT:        %58 = "memref.dim"(%54, %55) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %59 = arith.constant 1 : index
//CHECK-NEXT:        %60 = arith.subi %58, %59 : index
//CHECK-NEXT:        %61 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:        %62 = arith.constant 0 : index
//CHECK-NEXT:        %63 = arith.constant 1 : index
//CHECK-NEXT:        %64 = arith.constant 1 : index
//CHECK-NEXT:        %65 = "memref.dim"(%61, %62) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %66 = "omp.map.bounds"(%53, %60, %58, %57, %63) <{stride_in_bytes = true, operandSegmentSizes = array<i32: 1, 1, 1, 1, 1>}> : (index, index, index, index, index) -> !omp.map_bounds_ty
//CHECK-NEXT:        %67 = "omp.map.info"(%1, %52, %66) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 1 : ui64, name = "", partial_map = false, var_type = f32, operandSegmentSizes = array<i32: 1, 1, 0, 1>}> : (memref<memref<?xf32>>, !llvm.ptr, !omp.map_bounds_ty) -> memref<memref<?xf32>>
//CHECK-NEXT{LITERAL}:        %68 = "omp.map.info"(%1, %67) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 1 : ui64, members_index = [[0 : i64]], name = "b", partial_map = false, var_type = memref<?xf32>, operandSegmentSizes = array<i32: 1, 0, 1, 0>}> : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> memref<memref<?xf32>>
//CHECK-NEXT:        %69 = "omp.map.info"(%3) <{map_capture_type = #omp<variable_capture_kind (ByCopy)>, map_type = 512 : ui64, name = "i", partial_map = false, var_type = i32, operandSegmentSizes = array<i32: 1, 0, 0, 0>}> : (memref<i32>) -> memref<i32>
//CHECK-NEXT:        %70 = "memref.extract_aligned_pointer_as_index"(%2) : (memref<memref<?xf32>>) -> index
//CHECK-NEXT:        %71 = arith.index_cast %70 : index to i64
//CHECK-NEXT:        %72 = "llvm.inttoptr"(%71) : (i64) -> !llvm.ptr
//CHECK-NEXT:        %73 = arith.constant 0 : index
//CHECK-NEXT:        %74 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:        %75 = arith.constant 0 : index
//CHECK-NEXT:        %76 = arith.constant 1 : index
//CHECK-NEXT:        %77 = arith.constant 1 : index
//CHECK-NEXT:        %78 = "memref.dim"(%74, %75) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %79 = arith.constant 1 : index
//CHECK-NEXT:        %80 = arith.subi %78, %79 : index
//CHECK-NEXT:        %81 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:        %82 = arith.constant 0 : index
//CHECK-NEXT:        %83 = arith.constant 1 : index
//CHECK-NEXT:        %84 = arith.constant 1 : index
//CHECK-NEXT:        %85 = "memref.dim"(%81, %82) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %86 = "omp.map.bounds"(%73, %80, %78, %77, %83) <{stride_in_bytes = true, operandSegmentSizes = array<i32: 1, 1, 1, 1, 1>}> : (index, index, index, index, index) -> !omp.map_bounds_ty
//CHECK-NEXT:        %87 = "omp.map.info"(%2, %72, %86) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 515 : ui64, name = "", partial_map = false, var_type = f32, operandSegmentSizes = array<i32: 1, 1, 0, 1>}> : (memref<memref<?xf32>>, !llvm.ptr, !omp.map_bounds_ty) -> memref<memref<?xf32>>
//CHECK-NEXT{LITERAL}:        %88 = "omp.map.info"(%2, %87) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 513 : ui64, members_index = [[0 : i64]], name = "c", partial_map = false, var_type = memref<?xf32>, operandSegmentSizes = array<i32: 1, 0, 1, 0>}> : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> memref<memref<?xf32>>
//CHECK-NEXT:        "omp.target"(%49, %68, %69, %88, %48, %67, %87) <{operandSegmentSizes = array<i32: 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0>}> ({
//CHECK-NEXT:        ^1(%89 : memref<memref<?xf32>>, %90 : memref<memref<?xf32>>, %91 : memref<i32>, %92 : memref<memref<?xf32>>, %93 : memref<memref<?xf32>>, %94 : memref<memref<?xf32>>, %95 : memref<memref<?xf32>>):
//CHECK-NEXT:          %96 = arith.constant 1 : i32
//CHECK-NEXT:          %97 = arith.index_cast %96 : i32 to index
//CHECK-NEXT:          %98 = arith.constant 100 : i32
//CHECK-NEXT:          %99 = arith.index_cast %98 : i32 to index
//CHECK-NEXT:          %100 = arith.constant 1 : index
//CHECK-NEXT:          %101 = arith.index_cast %97 : index to i32
//CHECK-NEXT:          %102 = arith.constant 1 : index
//CHECK-NEXT:          %103 = arith.addi %99, %102 : index
//CHECK-NEXT:          %104 = scf.for %105 = %97 to %103 step %100 iter_args(%106 = %101) -> (i32) {
//CHECK-NEXT:            memref.store %106, %91[] : memref<i32>
//CHECK-NEXT:            %107 = memref.load %91[] : memref<i32>
//CHECK-NEXT:            %108 = arith.extui %107 : i32 to i64
//CHECK-NEXT:            %109 = arith.index_cast %108 : i64 to index
//CHECK-NEXT:            %110 = arith.constant 1 : index
//CHECK-NEXT:            %111 = arith.subi %109, %110 : index
//CHECK-NEXT:            %112 = memref.load %89[] : memref<memref<?xf32>>
//CHECK-NEXT:            %113 = memref.load %112[%111] : memref<?xf32>
//CHECK-NEXT:            %114 = memref.load %91[] : memref<i32>
//CHECK-NEXT:            %115 = arith.extui %114 : i32 to i64
//CHECK-NEXT:            %116 = arith.index_cast %115 : i64 to index
//CHECK-NEXT:            %117 = arith.constant 1 : index
//CHECK-NEXT:            %118 = arith.subi %116, %117 : index
//CHECK-NEXT:            %119 = memref.load %90[] : memref<memref<?xf32>>
//CHECK-NEXT:            %120 = memref.load %119[%118] : memref<?xf32>
//CHECK-NEXT:            %121 = arith.addf %113, %120 fastmath<contract> : f32
//CHECK-NEXT:            %122 = memref.load %91[] : memref<i32>
//CHECK-NEXT:            %123 = arith.extui %122 : i32 to i64
//CHECK-NEXT:            %124 = arith.index_cast %123 : i64 to index
//CHECK-NEXT:            %125 = arith.constant 1 : index
//CHECK-NEXT:            %126 = arith.subi %124, %125 : index
//CHECK-NEXT:            %127 = memref.load %92[] : memref<memref<?xf32>>
//CHECK-NEXT:            memref.store %121, %127[%126] : memref<?xf32>
//CHECK-NEXT:            %128 = arith.addi %105, %100 : index
//CHECK-NEXT:            %129 = memref.load %91[] : memref<i32>
//CHECK-NEXT:            %130 = arith.index_cast %100 : index to i32
//CHECK-NEXT:            %131 = arith.addi %129, %130 : i32
//CHECK-NEXT:            scf.yield %131 : i32
//CHECK-NEXT:          }
//CHECK-NEXT:          memref.store %104, %91[] : memref<i32>
//CHECK-NEXT:          "omp.terminator"() : () -> ()
//CHECK-NEXT:        }) : (memref<memref<?xf32>>, memref<memref<?xf32>>, memref<i32>, memref<memref<?xf32>>, memref<memref<?xf32>>, memref<memref<?xf32>>, memref<memref<?xf32>>) -> ()
//CHECK-NEXT:        %89 = "memref.extract_aligned_pointer_as_index"(%2) : (memref<memref<?xf32>>) -> index
//CHECK-NEXT:        %90 = arith.index_cast %89 : index to i64
//CHECK-NEXT:        %91 = "llvm.inttoptr"(%90) : (i64) -> !llvm.ptr
//CHECK-NEXT:        %92 = arith.constant 0 : index
//CHECK-NEXT:        %93 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:        %94 = arith.constant 0 : index
//CHECK-NEXT:        %95 = arith.constant 1 : index
//CHECK-NEXT:        %96 = arith.constant 1 : index
//CHECK-NEXT:        %97 = "memref.dim"(%93, %94) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %98 = arith.constant 1 : index
//CHECK-NEXT:        %99 = arith.subi %97, %98 : index
//CHECK-NEXT:        %100 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:        %101 = arith.constant 0 : index
//CHECK-NEXT:        %102 = arith.constant 1 : index
//CHECK-NEXT:        %103 = arith.constant 1 : index
//CHECK-NEXT:        %104 = "memref.dim"(%100, %101) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %105 = "omp.map.bounds"(%92, %99, %97, %96, %102) <{stride_in_bytes = true, operandSegmentSizes = array<i32: 1, 1, 1, 1, 1>}> : (index, index, index, index, index) -> !omp.map_bounds_ty
//CHECK-NEXT:        %106 = "omp.map.info"(%2, %91, %105) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 2 : ui64, name = "", partial_map = false, var_type = f32, operandSegmentSizes = array<i32: 1, 1, 0, 1>}> : (memref<memref<?xf32>>, !llvm.ptr, !omp.map_bounds_ty) -> memref<memref<?xf32>>
//CHECK-NEXT{LITERAL}:        %107 = "omp.map.info"(%2, %106) <{map_capture_type = #omp<variable_capture_kind (ByRef)>, map_type = 2 : ui64, members_index = [[0 : i64]], name = "c", partial_map = false, var_type = memref<?xf32>, operandSegmentSizes = array<i32: 1, 0, 1, 0>}> : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> memref<memref<?xf32>>
//CHECK-NEXT:        "omp.target_update"(%107, %106) <{operandSegmentSizes = array<i32: 0, 0, 0, 2>}> : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> ()
//CHECK-NEXT:        "omp.terminator"() : () -> ()
//CHECK-NEXT:      }) : (memref<memref<?xf32>>, memref<memref<?xf32>>) -> ()
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QQmain() {
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        func.call @_QMex7_testPcalc() : () -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    "llvm.mlir.global"() <{global_type = !llvm.array<{{[0-9]+}} x i8>, sym_name = "_{{.*}}", linkage = #llvm.linkage<"internal">, addr_space = 0 : i32, constant, value = "{{.*}}", unnamed_addr = 0 : i64}> ({
//CHECK-NEXT:    }) : () -> ()
//CHECK-NEXT:    func.func private @_FortranAProgramStart(i32, !llvm.ptr, !llvm.ptr, !llvm.ptr) -> () 
//CHECK-NEXT:    func.func private @_FortranAProgramEndStatement() -> () 
//CHECK-NEXT:    func.func @main(%0 : i32, %1 : !llvm.ptr, %2 : !llvm.ptr) -> i32 {
//CHECK-NEXT:      %3 = memref.alloc() : memref<1xmemref<memref<1xmemref<i8>>>>
//CHECK-NEXT:      %4 = arith.constant 0 : index
//CHECK-NEXT:      %5 = memref.load %3[%4] : memref<1xmemref<memref<1xmemref<i8>>>>
//CHECK-NEXT:      %6 = "memref.extract_aligned_pointer_as_index"(%5) : (memref<memref<1xmemref<i8>>>) -> index
//CHECK-NEXT:      %7 = arith.index_cast %6 : index to i64
//CHECK-NEXT:      %8 = "llvm.inttoptr"(%7) : (i64) -> !llvm.ptr
//CHECK-NEXT:      func.call @_FortranAProgramStart(%0, %1, %2, %8) : (i32, !llvm.ptr, !llvm.ptr, !llvm.ptr) -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        func.call @_QQmain() : () -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      func.call @_FortranAProgramEndStatement() : () -> ()
//CHECK-NEXT:      %9 = arith.constant 0 : i32
//CHECK-NEXT:      func.return %9 : i32
//CHECK-NEXT:    }
//CHECK-NEXT:  }
//CHECK-EMPTY:  
