// RUN: xftn %S/../../../../examples/fragments/pointers.F90 -DFRAGMENT_ONLY --stdout -t %S/tmp --cleanup --stages=flang,pre,ftn -v0 | FileCheck %s 
//CHECK:       builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.ident = "flang version 20.1.7 (https://github.com/llvm/llvm-project 6146a88f60492b520a36f8f8f3231e15f3cc6082)", llvm.target_triple = "x86_64-unknown-linux-gnu"} {
//CHECK-NEXT:    "memref.global"() <{sym_name = "_QMpointers_testEptr3", type = memref<memref<?xf32>>, initial_value, sym_visibility = "private"}> : () -> ()
//CHECK-NEXT:    func.func @_QMpointers_testPcalc() {
//CHECK-NEXT:      %0 = memref.get_global @_QMpointers_testEptr3 : memref<memref<?xf32>>
//CHECK-NEXT:      %1 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %2 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %3 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?x?x?xi32>>
//CHECK-NEXT:      %4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %5 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %6 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %7 = memref.get_global @_QMpointers_testFcalcEptr1 : memref<memref<?xf32>>
//CHECK-NEXT:      %8 = memref.get_global @_QMpointers_testFcalcEptr2 : memref<memref<?xf32>>
//CHECK-NEXT:      %9 = memref.get_global @_QMpointers_testFcalcEptr_md : memref<memref<?x?x?xi32>>
//CHECK-NEXT:      %10 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:      %11 = arith.constant 100 : index
//CHECK-NEXT:      %12 = memref.alloc(%11) : memref<?xf32>
//CHECK-NEXT:      memref.store %12, %1[] : memref<memref<?xf32>>
//CHECK-NEXT:      %13 = memref.alloc(%11) : memref<?xf32>
//CHECK-NEXT:      memref.store %13, %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %14 = arith.constant 10 : index
//CHECK-NEXT:      %15 = memref.alloc(%14, %14, %14) : memref<?x?x?xi32>
//CHECK-NEXT:      memref.store %15, %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:      %16 = arith.constant 1 : i32
//CHECK-NEXT:      %17 = arith.index_cast %16 : i32 to index
//CHECK-NEXT:      %18 = arith.constant 100 : i32
//CHECK-NEXT:      %19 = arith.index_cast %18 : i32 to index
//CHECK-NEXT:      %20 = arith.constant 1 : index
//CHECK-NEXT:      %21 = arith.index_cast %17 : index to i32
//CHECK-NEXT:      %22 = arith.addi %19, %20 : index
//CHECK-NEXT:      %23 = scf.for %24 = %17 to %22 step %20 iter_args(%25 = %21) -> (i32) {
//CHECK-NEXT:        memref.store %25, %4[] : memref<i32>
//CHECK-NEXT:        %26 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %27 = arith.sitofp %26 : i32 to f32
//CHECK-NEXT:        %28 = arith.extui %26 : i32 to i64
//CHECK-NEXT:        %29 = arith.index_cast %28 : i64 to index
//CHECK-NEXT:        %30 = arith.subi %29, %20 : index
//CHECK-NEXT:        %31 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:        memref.store %27, %31[%30] : memref<?xf32>
//CHECK-NEXT:        %32 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %33 = arith.subi %18, %32 : i32
//CHECK-NEXT:        %34 = arith.sitofp %33 : i32 to f32
//CHECK-NEXT:        %35 = arith.extui %32 : i32 to i64
//CHECK-NEXT:        %36 = arith.index_cast %35 : i64 to index
//CHECK-NEXT:        %37 = arith.subi %36, %20 : index
//CHECK-NEXT:        %38 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:        memref.store %34, %38[%37] : memref<?xf32>
//CHECK-NEXT:        %39 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %40 = arith.index_cast %20 : index to i32
//CHECK-NEXT:        %41 = arith.addi %39, %40 : i32
//CHECK-NEXT:        scf.yield %41 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %23, %4[] : memref<i32>
//CHECK-NEXT:      %42 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %42, %7[] : memref<memref<?xf32>>
//CHECK-NEXT:      %43 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %44 = arith.constant true
//CHECK-NEXT:        %45 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %44, %45[] : memref<i1>
//CHECK-NEXT:        %46 = arith.constant {{.*}} : index
//CHECK-NEXT:        %47 = arith.index_cast %46 : index to i64
//CHECK-NEXT:        %48 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %49 = "llvm.insertvalue"(%48, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %50 = "llvm.insertvalue"(%49, %47) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %51 = arith.constant 29 : i32
//CHECK-NEXT:        %52 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %51, %52[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%45, %50, %52) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %53 = memref.load %7[] : memref<memref<?xf32>>
//CHECK-NEXT:        %54 = arith.constant 0 : index
//CHECK-NEXT:        %55 = "memref.dim"(%53, %54) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %56 = arith.index_cast %55 : index to i64
//CHECK-NEXT:        %57 = arith.trunci %56 : i64 to i32
//CHECK-NEXT:        %58 = arith.cmpi eq, %57, %18 : i32
//CHECK-NEXT:        %59 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %58, %59[] : memref<i1>
//CHECK-NEXT:        %60 = arith.constant {{.*}} : index
//CHECK-NEXT:        %61 = arith.index_cast %60 : index to i64
//CHECK-NEXT:        %62 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %63 = "llvm.insertvalue"(%62, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %64 = "llvm.insertvalue"(%63, %61) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %65 = arith.constant 30 : i32
//CHECK-NEXT:        %66 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %65, %66[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%59, %64, %66) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %67 = memref.load %7[] : memref<memref<?xf32>>
//CHECK-NEXT:        %68 = arith.constant 0 : index
//CHECK-NEXT:        %69 = "memref.dim"(%67, %68) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %70 = arith.index_cast %69 : index to i64
//CHECK-NEXT:        %71 = arith.trunci %70 : i64 to i32
//CHECK-NEXT:        %72 = arith.cmpi eq, %71, %18 : i32
//CHECK-NEXT:        %73 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %72, %73[] : memref<i1>
//CHECK-NEXT:        %74 = arith.constant {{.*}} : index
//CHECK-NEXT:        %75 = arith.index_cast %74 : index to i64
//CHECK-NEXT:        %76 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %77 = "llvm.insertvalue"(%76, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %78 = "llvm.insertvalue"(%77, %75) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %79 = arith.constant 31 : i32
//CHECK-NEXT:        %80 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %79, %80[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%73, %78, %80) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %81 = scf.for %82 = %17 to %22 step %20 iter_args(%83 = %21) -> (i32) {
//CHECK-NEXT:        memref.store %83, %4[] : memref<i32>
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %84 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %85 = arith.extui %84 : i32 to i64
//CHECK-NEXT:          %86 = arith.index_cast %85 : i64 to index
//CHECK-NEXT:          %87 = arith.subi %86, %20 : index
//CHECK-NEXT:          %88 = memref.load %7[] : memref<memref<?xf32>>
//CHECK-NEXT:          %89 = memref.load %88[%87] : memref<?xf32>
//CHECK-NEXT:          %90 = arith.sitofp %84 : i32 to f32
//CHECK-NEXT:          %91 = arith.cmpf oeq, %89, %90 : f32
//CHECK-NEXT:          %92 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %91, %92[] : memref<i1>
//CHECK-NEXT:          %93 = arith.constant {{.*}} : index
//CHECK-NEXT:          %94 = arith.index_cast %93 : index to i64
//CHECK-NEXT:          %95 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %96 = "llvm.insertvalue"(%95, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %97 = "llvm.insertvalue"(%96, %94) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %98 = arith.constant 33 : i32
//CHECK-NEXT:          %99 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %98, %99[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%92, %97, %99) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %100 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %101 = arith.index_cast %20 : index to i32
//CHECK-NEXT:        %102 = arith.addi %100, %101 : i32
//CHECK-NEXT:        scf.yield %102 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %81, %4[] : memref<i32>
//CHECK-NEXT:      %103 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %103, %8[] : memref<memref<?xf32>>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %104 = arith.constant true
//CHECK-NEXT:        %105 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %104, %105[] : memref<i1>
//CHECK-NEXT:        %106 = arith.constant {{.*}} : index
//CHECK-NEXT:        %107 = arith.index_cast %106 : index to i64
//CHECK-NEXT:        %108 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %109 = "llvm.insertvalue"(%108, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %110 = "llvm.insertvalue"(%109, %107) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %111 = arith.constant 38 : i32
//CHECK-NEXT:        %112 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %111, %112[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%105, %110, %112) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %113 = memref.load %8[] : memref<memref<?xf32>>
//CHECK-NEXT:        %114 = arith.constant 0 : index
//CHECK-NEXT:        %115 = "memref.dim"(%113, %114) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %116 = arith.index_cast %115 : index to i64
//CHECK-NEXT:        %117 = arith.trunci %116 : i64 to i32
//CHECK-NEXT:        %118 = arith.cmpi eq, %117, %18 : i32
//CHECK-NEXT:        %119 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %118, %119[] : memref<i1>
//CHECK-NEXT:        %120 = arith.constant {{.*}} : index
//CHECK-NEXT:        %121 = arith.index_cast %120 : index to i64
//CHECK-NEXT:        %122 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %123 = "llvm.insertvalue"(%122, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %124 = "llvm.insertvalue"(%123, %121) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %125 = arith.constant 39 : i32
//CHECK-NEXT:        %126 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %125, %126[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%119, %124, %126) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %127 = memref.load %8[] : memref<memref<?xf32>>
//CHECK-NEXT:        %128 = arith.constant 0 : index
//CHECK-NEXT:        %129 = "memref.dim"(%127, %128) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %130 = arith.index_cast %129 : index to i64
//CHECK-NEXT:        %131 = arith.trunci %130 : i64 to i32
//CHECK-NEXT:        %132 = arith.cmpi eq, %131, %18 : i32
//CHECK-NEXT:        %133 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %132, %133[] : memref<i1>
//CHECK-NEXT:        %134 = arith.constant {{.*}} : index
//CHECK-NEXT:        %135 = arith.index_cast %134 : index to i64
//CHECK-NEXT:        %136 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %137 = "llvm.insertvalue"(%136, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %138 = "llvm.insertvalue"(%137, %135) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %139 = arith.constant 40 : i32
//CHECK-NEXT:        %140 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %139, %140[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%133, %138, %140) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %141 = scf.for %142 = %17 to %22 step %20 iter_args(%143 = %21) -> (i32) {
//CHECK-NEXT:        memref.store %143, %4[] : memref<i32>
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %144 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %145 = arith.extui %144 : i32 to i64
//CHECK-NEXT:          %146 = arith.index_cast %145 : i64 to index
//CHECK-NEXT:          %147 = arith.subi %146, %20 : index
//CHECK-NEXT:          %148 = memref.load %8[] : memref<memref<?xf32>>
//CHECK-NEXT:          %149 = memref.load %148[%147] : memref<?xf32>
//CHECK-NEXT:          %150 = arith.sitofp %144 : i32 to f32
//CHECK-NEXT:          %151 = arith.cmpf oeq, %149, %150 : f32
//CHECK-NEXT:          %152 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %151, %152[] : memref<i1>
//CHECK-NEXT:          %153 = arith.constant {{.*}} : index
//CHECK-NEXT:          %154 = arith.index_cast %153 : index to i64
//CHECK-NEXT:          %155 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %156 = "llvm.insertvalue"(%155, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %157 = "llvm.insertvalue"(%156, %154) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %158 = arith.constant 42 : i32
//CHECK-NEXT:          %159 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %158, %159[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%152, %157, %159) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %160 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %161 = arith.index_cast %20 : index to i32
//CHECK-NEXT:        %162 = arith.addi %160, %161 : i32
//CHECK-NEXT:        scf.yield %162 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %141, %4[] : memref<i32>
//CHECK-NEXT:      %163 = memref.load %7[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %163, %0[] : memref<memref<?xf32>>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %164 = arith.constant true
//CHECK-NEXT:        %165 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %164, %165[] : memref<i1>
//CHECK-NEXT:        %166 = arith.constant {{.*}} : index
//CHECK-NEXT:        %167 = arith.index_cast %166 : index to i64
//CHECK-NEXT:        %168 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %169 = "llvm.insertvalue"(%168, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %170 = "llvm.insertvalue"(%169, %167) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %171 = arith.constant 47 : i32
//CHECK-NEXT:        %172 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %171, %172[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%165, %170, %172) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %173 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:        %174 = arith.constant 0 : index
//CHECK-NEXT:        %175 = "memref.dim"(%173, %174) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %176 = arith.index_cast %175 : index to i64
//CHECK-NEXT:        %177 = arith.trunci %176 : i64 to i32
//CHECK-NEXT:        %178 = arith.cmpi eq, %177, %18 : i32
//CHECK-NEXT:        %179 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %178, %179[] : memref<i1>
//CHECK-NEXT:        %180 = arith.constant {{.*}} : index
//CHECK-NEXT:        %181 = arith.index_cast %180 : index to i64
//CHECK-NEXT:        %182 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %183 = "llvm.insertvalue"(%182, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %184 = "llvm.insertvalue"(%183, %181) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %185 = arith.constant 48 : i32
//CHECK-NEXT:        %186 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %185, %186[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%179, %184, %186) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %187 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:        %188 = arith.constant 0 : index
//CHECK-NEXT:        %189 = "memref.dim"(%187, %188) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %190 = arith.index_cast %189 : index to i64
//CHECK-NEXT:        %191 = arith.trunci %190 : i64 to i32
//CHECK-NEXT:        %192 = arith.cmpi eq, %191, %18 : i32
//CHECK-NEXT:        %193 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %192, %193[] : memref<i1>
//CHECK-NEXT:        %194 = arith.constant {{.*}} : index
//CHECK-NEXT:        %195 = arith.index_cast %194 : index to i64
//CHECK-NEXT:        %196 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %197 = "llvm.insertvalue"(%196, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %198 = "llvm.insertvalue"(%197, %195) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %199 = arith.constant 49 : i32
//CHECK-NEXT:        %200 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %199, %200[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%193, %198, %200) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %201 = scf.for %202 = %17 to %22 step %20 iter_args(%203 = %21) -> (i32) {
//CHECK-NEXT:        memref.store %203, %4[] : memref<i32>
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %204 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %205 = arith.extui %204 : i32 to i64
//CHECK-NEXT:          %206 = arith.index_cast %205 : i64 to index
//CHECK-NEXT:          %207 = arith.subi %206, %20 : index
//CHECK-NEXT:          %208 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:          %209 = memref.load %208[%207] : memref<?xf32>
//CHECK-NEXT:          %210 = arith.sitofp %204 : i32 to f32
//CHECK-NEXT:          %211 = arith.cmpf oeq, %209, %210 : f32
//CHECK-NEXT:          %212 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %211, %212[] : memref<i1>
//CHECK-NEXT:          %213 = arith.constant {{.*}} : index
//CHECK-NEXT:          %214 = arith.index_cast %213 : index to i64
//CHECK-NEXT:          %215 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %216 = "llvm.insertvalue"(%215, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %217 = "llvm.insertvalue"(%216, %214) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %218 = arith.constant 51 : i32
//CHECK-NEXT:          %219 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %218, %219[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%212, %217, %219) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %220 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %221 = arith.index_cast %20 : index to i32
//CHECK-NEXT:        %222 = arith.addi %220, %221 : i32
//CHECK-NEXT:        scf.yield %222 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %201, %4[] : memref<i32>
//CHECK-NEXT:      %223 = arith.constant 3.400000e+01 : f32
//CHECK-NEXT:      %224 = arith.constant 19 : index
//CHECK-NEXT:      %225 = memref.load %7[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %223, %225[%224] : memref<?xf32>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %226 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:        %227 = memref.load %226[%224] : memref<?xf32>
//CHECK-NEXT:        %228 = arith.cmpf oeq, %227, %223 : f32
//CHECK-NEXT:        %229 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %228, %229[] : memref<i1>
//CHECK-NEXT:        %230 = arith.constant {{.*}} : index
//CHECK-NEXT:        %231 = arith.index_cast %230 : index to i64
//CHECK-NEXT:        %232 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %233 = "llvm.insertvalue"(%232, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %234 = "llvm.insertvalue"(%233, %231) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %235 = arith.constant 56 : i32
//CHECK-NEXT:        %236 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %235, %236[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%229, %234, %236) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %237 = memref.load %7[] : memref<memref<?xf32>>
//CHECK-NEXT:        %238 = memref.load %237[%224] : memref<?xf32>
//CHECK-NEXT:        %239 = arith.cmpf oeq, %238, %223 : f32
//CHECK-NEXT:        %240 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %239, %240[] : memref<i1>
//CHECK-NEXT:        %241 = arith.constant {{.*}} : index
//CHECK-NEXT:        %242 = arith.index_cast %241 : index to i64
//CHECK-NEXT:        %243 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %244 = "llvm.insertvalue"(%243, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %245 = "llvm.insertvalue"(%244, %242) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %246 = arith.constant 57 : i32
//CHECK-NEXT:        %247 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %246, %247[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%240, %245, %247) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %248 = memref.load %8[] : memref<memref<?xf32>>
//CHECK-NEXT:        %249 = memref.load %248[%224] : memref<?xf32>
//CHECK-NEXT:        %250 = arith.cmpf oeq, %249, %223 : f32
//CHECK-NEXT:        %251 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %250, %251[] : memref<i1>
//CHECK-NEXT:        %252 = arith.constant {{.*}} : index
//CHECK-NEXT:        %253 = arith.index_cast %252 : index to i64
//CHECK-NEXT:        %254 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %255 = "llvm.insertvalue"(%254, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %256 = "llvm.insertvalue"(%255, %253) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %257 = arith.constant 58 : i32
//CHECK-NEXT:        %258 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %257, %258[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%251, %256, %258) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %259 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:        %260 = memref.load %259[%224] : memref<?xf32>
//CHECK-NEXT:        %261 = arith.cmpf oeq, %260, %223 : f32
//CHECK-NEXT:        %262 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %261, %262[] : memref<i1>
//CHECK-NEXT:        %263 = arith.constant {{.*}} : index
//CHECK-NEXT:        %264 = arith.index_cast %263 : index to i64
//CHECK-NEXT:        %265 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %266 = "llvm.insertvalue"(%265, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %267 = "llvm.insertvalue"(%266, %264) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %268 = arith.constant 59 : i32
//CHECK-NEXT:        %269 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %268, %269[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%262, %267, %269) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %270 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %270, %8[] : memref<memref<?xf32>>
//CHECK-NEXT:      %271 = arith.constant 20 : i32
//CHECK-NEXT:      %272 = scf.for %273 = %17 to %22 step %20 iter_args(%274 = %21) -> (i32) {
//CHECK-NEXT:        memref.store %274, %4[] : memref<i32>
//CHECK-NEXT:        %275 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %276 = arith.cmpi eq, %275, %271 : i32
//CHECK-NEXT:        scf.if %276 {
//CHECK-NEXT:          "memref.alloca_scope"() ({
//CHECK-NEXT:            %277 = memref.load %4[] : memref<i32>
//CHECK-NEXT:            %278 = arith.extui %277 : i32 to i64
//CHECK-NEXT:            %279 = arith.index_cast %278 : i64 to index
//CHECK-NEXT:            %280 = arith.subi %279, %20 : index
//CHECK-NEXT:            %281 = memref.load %7[] : memref<memref<?xf32>>
//CHECK-NEXT:            %282 = memref.load %281[%280] : memref<?xf32>
//CHECK-NEXT:            %283 = arith.cmpf oeq, %282, %223 : f32
//CHECK-NEXT:            %284 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:            memref.store %283, %284[] : memref<i1>
//CHECK-NEXT:            %285 = arith.constant {{.*}} : index
//CHECK-NEXT:            %286 = arith.index_cast %285 : index to i64
//CHECK-NEXT:            %287 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:            %288 = "llvm.insertvalue"(%287, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:            %289 = "llvm.insertvalue"(%288, %286) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:            %290 = arith.constant 65 : i32
//CHECK-NEXT:            %291 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:            memref.store %290, %291[] : memref<i32>
//CHECK-NEXT:            func.call @_QPassert(%284, %289, %291) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:            "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:          }) : () -> ()
//CHECK-NEXT:        } else {
//CHECK-NEXT:          "memref.alloca_scope"() ({
//CHECK-NEXT:            %292 = memref.load %4[] : memref<i32>
//CHECK-NEXT:            %293 = arith.extui %292 : i32 to i64
//CHECK-NEXT:            %294 = arith.index_cast %293 : i64 to index
//CHECK-NEXT:            %295 = arith.subi %294, %20 : index
//CHECK-NEXT:            %296 = memref.load %7[] : memref<memref<?xf32>>
//CHECK-NEXT:            %297 = memref.load %296[%295] : memref<?xf32>
//CHECK-NEXT:            %298 = arith.sitofp %292 : i32 to f32
//CHECK-NEXT:            %299 = arith.cmpf oeq, %297, %298 : f32
//CHECK-NEXT:            %300 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:            memref.store %299, %300[] : memref<i1>
//CHECK-NEXT:            %301 = arith.constant {{.*}} : index
//CHECK-NEXT:            %302 = arith.index_cast %301 : index to i64
//CHECK-NEXT:            %303 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:            %304 = "llvm.insertvalue"(%303, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:            %305 = "llvm.insertvalue"(%304, %302) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:            %306 = arith.constant 67 : i32
//CHECK-NEXT:            %307 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:            memref.store %306, %307[] : memref<i32>
//CHECK-NEXT:            func.call @_QPassert(%300, %305, %307) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:            "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:          }) : () -> ()
//CHECK-NEXT:        }
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %308 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %309 = arith.extui %308 : i32 to i64
//CHECK-NEXT:          %310 = arith.index_cast %309 : i64 to index
//CHECK-NEXT:          %311 = arith.subi %310, %20 : index
//CHECK-NEXT:          %312 = memref.load %8[] : memref<memref<?xf32>>
//CHECK-NEXT:          %313 = memref.load %312[%311] : memref<?xf32>
//CHECK-NEXT:          %314 = arith.subi %18, %308 : i32
//CHECK-NEXT:          %315 = arith.sitofp %314 : i32 to f32
//CHECK-NEXT:          %316 = arith.cmpf oeq, %313, %315 : f32
//CHECK-NEXT:          %317 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %316, %317[] : memref<i1>
//CHECK-NEXT:          %318 = arith.constant {{.*}} : index
//CHECK-NEXT:          %319 = arith.index_cast %318 : index to i64
//CHECK-NEXT:          %320 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %321 = "llvm.insertvalue"(%320, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %322 = "llvm.insertvalue"(%321, %319) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %323 = arith.constant 69 : i32
//CHECK-NEXT:          %324 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %323, %324[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%317, %322, %324) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %325 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %326 = arith.index_cast %20 : index to i32
//CHECK-NEXT:        %327 = arith.addi %325, %326 : i32
//CHECK-NEXT:        scf.yield %327 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %272, %4[] : memref<i32>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %328 = "memref.extract_aligned_pointer_as_index"(%7) : (memref<memref<?xf32>>) -> index
//CHECK-NEXT:        %329 = arith.index_cast %328 : index to i64
//CHECK-NEXT:        %330 = "llvm.inttoptr"(%329) : (i64) -> !llvm.ptr
//CHECK-NEXT:        %331 = "memref.extract_aligned_pointer_as_index"(%8) : (memref<memref<?xf32>>) -> index
//CHECK-NEXT:        %332 = arith.index_cast %331 : index to i64
//CHECK-NEXT:        %333 = "llvm.inttoptr"(%332) : (i64) -> !llvm.ptr
//CHECK-NEXT:        func.call @_QMpointers_testPswap(%330, %333) : (!llvm.ptr, !llvm.ptr) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %334 = scf.for %335 = %17 to %22 step %20 iter_args(%336 = %21) -> (i32) {
//CHECK-NEXT:        memref.store %336, %4[] : memref<i32>
//CHECK-NEXT:        %337 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %338 = arith.cmpi eq, %337, %271 : i32
//CHECK-NEXT:        scf.if %338 {
//CHECK-NEXT:          "memref.alloca_scope"() ({
//CHECK-NEXT:            %339 = memref.load %4[] : memref<i32>
//CHECK-NEXT:            %340 = arith.extui %339 : i32 to i64
//CHECK-NEXT:            %341 = arith.index_cast %340 : i64 to index
//CHECK-NEXT:            %342 = arith.subi %341, %20 : index
//CHECK-NEXT:            %343 = memref.load %8[] : memref<memref<?xf32>>
//CHECK-NEXT:            %344 = memref.load %343[%342] : memref<?xf32>
//CHECK-NEXT:            %345 = arith.cmpf oeq, %344, %223 : f32
//CHECK-NEXT:            %346 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:            memref.store %345, %346[] : memref<i1>
//CHECK-NEXT:            %347 = arith.constant {{.*}} : index
//CHECK-NEXT:            %348 = arith.index_cast %347 : index to i64
//CHECK-NEXT:            %349 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:            %350 = "llvm.insertvalue"(%349, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:            %351 = "llvm.insertvalue"(%350, %348) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:            %352 = arith.constant 78 : i32
//CHECK-NEXT:            %353 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:            memref.store %352, %353[] : memref<i32>
//CHECK-NEXT:            func.call @_QPassert(%346, %351, %353) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:            "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:          }) : () -> ()
//CHECK-NEXT:        } else {
//CHECK-NEXT:          "memref.alloca_scope"() ({
//CHECK-NEXT:            %354 = memref.load %4[] : memref<i32>
//CHECK-NEXT:            %355 = arith.extui %354 : i32 to i64
//CHECK-NEXT:            %356 = arith.index_cast %355 : i64 to index
//CHECK-NEXT:            %357 = arith.subi %356, %20 : index
//CHECK-NEXT:            %358 = memref.load %8[] : memref<memref<?xf32>>
//CHECK-NEXT:            %359 = memref.load %358[%357] : memref<?xf32>
//CHECK-NEXT:            %360 = arith.sitofp %354 : i32 to f32
//CHECK-NEXT:            %361 = arith.cmpf oeq, %359, %360 : f32
//CHECK-NEXT:            %362 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:            memref.store %361, %362[] : memref<i1>
//CHECK-NEXT:            %363 = arith.constant {{.*}} : index
//CHECK-NEXT:            %364 = arith.index_cast %363 : index to i64
//CHECK-NEXT:            %365 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:            %366 = "llvm.insertvalue"(%365, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:            %367 = "llvm.insertvalue"(%366, %364) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:            %368 = arith.constant 80 : i32
//CHECK-NEXT:            %369 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:            memref.store %368, %369[] : memref<i32>
//CHECK-NEXT:            func.call @_QPassert(%362, %367, %369) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:            "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:          }) : () -> ()
//CHECK-NEXT:        }
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %370 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %371 = arith.extui %370 : i32 to i64
//CHECK-NEXT:          %372 = arith.index_cast %371 : i64 to index
//CHECK-NEXT:          %373 = arith.subi %372, %20 : index
//CHECK-NEXT:          %374 = memref.load %7[] : memref<memref<?xf32>>
//CHECK-NEXT:          %375 = memref.load %374[%373] : memref<?xf32>
//CHECK-NEXT:          %376 = arith.subi %18, %370 : i32
//CHECK-NEXT:          %377 = arith.sitofp %376 : i32 to f32
//CHECK-NEXT:          %378 = arith.cmpf oeq, %375, %377 : f32
//CHECK-NEXT:          %379 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %378, %379[] : memref<i1>
//CHECK-NEXT:          %380 = arith.constant {{.*}} : index
//CHECK-NEXT:          %381 = arith.index_cast %380 : index to i64
//CHECK-NEXT:          %382 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %383 = "llvm.insertvalue"(%382, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %384 = "llvm.insertvalue"(%383, %381) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %385 = arith.constant 82 : i32
//CHECK-NEXT:          %386 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %385, %386[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%379, %384, %386) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %387 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %388 = arith.index_cast %20 : index to i32
//CHECK-NEXT:        %389 = arith.addi %387, %388 : i32
//CHECK-NEXT:        scf.yield %389 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %334, %4[] : memref<i32>
//CHECK-NEXT:      %390 = arith.constant 2 : index
//CHECK-NEXT:      %391 = memref.load %7[] : memref<memref<?xf32>>
//CHECK-NEXT:      %392 = memref.load %391[%390] : memref<?xf32>
//CHECK-NEXT:      memref.store %392, %10[] : memref<f32>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %393 = memref.load %10[] : memref<f32>
//CHECK-NEXT:        %394 = arith.constant 9.700000e+01 : f32
//CHECK-NEXT:        %395 = arith.cmpf oeq, %393, %394 : f32
//CHECK-NEXT:        %396 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %395, %396[] : memref<i1>
//CHECK-NEXT:        %397 = arith.constant {{.*}} : index
//CHECK-NEXT:        %398 = arith.index_cast %397 : index to i64
//CHECK-NEXT:        %399 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %400 = "llvm.insertvalue"(%399, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %401 = "llvm.insertvalue"(%400, %398) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %402 = arith.constant 87 : i32
//CHECK-NEXT:        %403 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %402, %403[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%396, %401, %403) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %404 = "memref.extract_aligned_pointer_as_index"(%7) : (memref<memref<?xf32>>) -> index
//CHECK-NEXT:        %405 = arith.index_cast %404 : index to i64
//CHECK-NEXT:        %406 = "llvm.inttoptr"(%405) : (i64) -> !llvm.ptr
//CHECK-NEXT:        %407 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %271, %407[] : memref<i32>
//CHECK-NEXT:        %408 = arith.constant 3.100000e+00 : f32
//CHECK-NEXT:        %409 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %408, %409[] : memref<f32>
//CHECK-NEXT:        func.call @_QMpointers_testPmodify_array_ptr_one(%406, %407, %409) : (!llvm.ptr, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %410 = memref.load %7[] : memref<memref<?xf32>>
//CHECK-NEXT:        %411 = memref.load %410[%224] : memref<?xf32>
//CHECK-NEXT:        %412 = arith.constant 3.100000e+00 : f32
//CHECK-NEXT:        %413 = arith.cmpf oeq, %411, %412 : f32
//CHECK-NEXT:        %414 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %413, %414[] : memref<i1>
//CHECK-NEXT:        %415 = arith.constant {{.*}} : index
//CHECK-NEXT:        %416 = arith.index_cast %415 : index to i64
//CHECK-NEXT:        %417 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %418 = "llvm.insertvalue"(%417, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %419 = "llvm.insertvalue"(%418, %416) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %420 = arith.constant 90 : i32
//CHECK-NEXT:        %421 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %420, %421[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%414, %419, %421) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %422 = arith.constant 10 : i32
//CHECK-NEXT:      %423 = arith.index_cast %422 : i32 to index
//CHECK-NEXT:      %424 = arith.addi %423, %20 : index
//CHECK-NEXT:      %425 = scf.for %426 = %17 to %424 step %20 iter_args(%427 = %21) -> (i32) {
//CHECK-NEXT:        memref.store %427, %4[] : memref<i32>
//CHECK-NEXT:        %428 = scf.for %429 = %17 to %424 step %20 iter_args(%430 = %21) -> (i32) {
//CHECK-NEXT:          memref.store %430, %5[] : memref<i32>
//CHECK-NEXT:          %431 = scf.for %432 = %17 to %424 step %20 iter_args(%433 = %21) -> (i32) {
//CHECK-NEXT:            memref.store %433, %6[] : memref<i32>
//CHECK-NEXT:            %434 = memref.load %6[] : memref<i32>
//CHECK-NEXT:            %435 = memref.load %5[] : memref<i32>
//CHECK-NEXT:            %436 = arith.muli %435, %422 : i32
//CHECK-NEXT:            %437 = arith.addi %434, %436 : i32
//CHECK-NEXT:            %438 = memref.load %4[] : memref<i32>
//CHECK-NEXT:            %439 = arith.muli %438, %18 : i32
//CHECK-NEXT:            %440 = arith.addi %437, %439 : i32
//CHECK-NEXT:            %441 = arith.extui %434 : i32 to i64
//CHECK-NEXT:            %442 = arith.index_cast %441 : i64 to index
//CHECK-NEXT:            %443 = arith.subi %442, %20 : index
//CHECK-NEXT:            %444 = arith.extui %435 : i32 to i64
//CHECK-NEXT:            %445 = arith.index_cast %444 : i64 to index
//CHECK-NEXT:            %446 = arith.subi %445, %20 : index
//CHECK-NEXT:            %447 = arith.extui %438 : i32 to i64
//CHECK-NEXT:            %448 = arith.index_cast %447 : i64 to index
//CHECK-NEXT:            %449 = arith.subi %448, %20 : index
//CHECK-NEXT:            %450 = memref.load %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:            memref.store %440, %450[%449, %446, %443] : memref<?x?x?xi32>
//CHECK-NEXT:            %451 = memref.load %6[] : memref<i32>
//CHECK-NEXT:            %452 = arith.index_cast %20 : index to i32
//CHECK-NEXT:            %453 = arith.addi %451, %452 : i32
//CHECK-NEXT:            scf.yield %453 : i32
//CHECK-NEXT:          }
//CHECK-NEXT:          memref.store %431, %6[] : memref<i32>
//CHECK-NEXT:          %454 = memref.load %5[] : memref<i32>
//CHECK-NEXT:          %455 = arith.index_cast %20 : index to i32
//CHECK-NEXT:          %456 = arith.addi %454, %455 : i32
//CHECK-NEXT:          scf.yield %456 : i32
//CHECK-NEXT:        }
//CHECK-NEXT:        memref.store %428, %5[] : memref<i32>
//CHECK-NEXT:        %457 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %458 = arith.index_cast %20 : index to i32
//CHECK-NEXT:        %459 = arith.addi %457, %458 : i32
//CHECK-NEXT:        scf.yield %459 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %425, %4[] : memref<i32>
//CHECK-NEXT:      %460 = memref.load %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:      memref.store %460, %9[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %461 = arith.constant true
//CHECK-NEXT:        %462 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %461, %462[] : memref<i1>
//CHECK-NEXT:        %463 = arith.constant {{.*}} : index
//CHECK-NEXT:        %464 = arith.index_cast %463 : index to i64
//CHECK-NEXT:        %465 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %466 = "llvm.insertvalue"(%465, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %467 = "llvm.insertvalue"(%466, %464) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %468 = arith.constant 101 : i32
//CHECK-NEXT:        %469 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %468, %469[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%462, %467, %469) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %470 = memref.load %9[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %471 = arith.constant 0 : index
//CHECK-NEXT:        %472 = "memref.dim"(%470, %471) : (memref<?x?x?xi32>, index) -> index
//CHECK-NEXT:        %473 = arith.index_cast %472 : index to i64
//CHECK-NEXT:        %474 = "memref.dim"(%470, %20) : (memref<?x?x?xi32>, index) -> index
//CHECK-NEXT:        %475 = arith.index_cast %474 : index to i64
//CHECK-NEXT:        %476 = arith.muli %473, %475 : i64
//CHECK-NEXT:        %477 = "memref.dim"(%470, %390) : (memref<?x?x?xi32>, index) -> index
//CHECK-NEXT:        %478 = arith.index_cast %477 : index to i64
//CHECK-NEXT:        %479 = arith.muli %476, %478 : i64
//CHECK-NEXT:        %480 = arith.trunci %479 : i64 to i32
//CHECK-NEXT:        %481 = arith.constant 1000 : i32
//CHECK-NEXT:        %482 = arith.cmpi eq, %480, %481 : i32
//CHECK-NEXT:        %483 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %482, %483[] : memref<i1>
//CHECK-NEXT:        %484 = arith.constant {{.*}} : index
//CHECK-NEXT:        %485 = arith.index_cast %484 : index to i64
//CHECK-NEXT:        %486 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %487 = "llvm.insertvalue"(%486, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %488 = "llvm.insertvalue"(%487, %485) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %489 = arith.constant 102 : i32
//CHECK-NEXT:        %490 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %489, %490[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%483, %488, %490) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %491 = memref.load %9[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %492 = "memref.dim"(%491, %20) : (memref<?x?x?xi32>, index) -> index
//CHECK-NEXT:        %493 = arith.index_cast %492 : index to i64
//CHECK-NEXT:        %494 = arith.trunci %493 : i64 to i32
//CHECK-NEXT:        %495 = arith.cmpi eq, %494, %422 : i32
//CHECK-NEXT:        %496 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %495, %496[] : memref<i1>
//CHECK-NEXT:        %497 = arith.constant {{.*}} : index
//CHECK-NEXT:        %498 = arith.index_cast %497 : index to i64
//CHECK-NEXT:        %499 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %500 = "llvm.insertvalue"(%499, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %501 = "llvm.insertvalue"(%500, %498) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %502 = arith.constant 103 : i32
//CHECK-NEXT:        %503 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %502, %503[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%496, %501, %503) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %504 = arith.constant 3 : index
//CHECK-NEXT:        %505 = arith.constant 4 : index
//CHECK-NEXT:        %506 = memref.load %9[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %507 = memref.load %506[%505, %504, %390] : memref<?x?x?xi32>
//CHECK-NEXT:        %508 = arith.constant 543 : i32
//CHECK-NEXT:        %509 = arith.cmpi eq, %507, %508 : i32
//CHECK-NEXT:        %510 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %509, %510[] : memref<i1>
//CHECK-NEXT:        %511 = arith.constant {{.*}} : index
//CHECK-NEXT:        %512 = arith.index_cast %511 : index to i64
//CHECK-NEXT:        %513 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %514 = "llvm.insertvalue"(%513, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %515 = "llvm.insertvalue"(%514, %512) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %516 = arith.constant 104 : i32
//CHECK-NEXT:        %517 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %516, %517[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%510, %515, %517) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %518 = arith.constant 7 : index
//CHECK-NEXT:        %519 = arith.constant 8 : index
//CHECK-NEXT:        %520 = arith.constant 0 : index
//CHECK-NEXT:        %521 = memref.load %9[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %522 = memref.load %521[%520, %519, %518] : memref<?x?x?xi32>
//CHECK-NEXT:        %523 = arith.constant 198 : i32
//CHECK-NEXT:        %524 = arith.cmpi eq, %522, %523 : i32
//CHECK-NEXT:        %525 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %524, %525[] : memref<i1>
//CHECK-NEXT:        %526 = arith.constant {{.*}} : index
//CHECK-NEXT:        %527 = arith.index_cast %526 : index to i64
//CHECK-NEXT:        %528 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %529 = "llvm.insertvalue"(%528, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %530 = "llvm.insertvalue"(%529, %527) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %531 = arith.constant 105 : i32
//CHECK-NEXT:        %532 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %531, %532[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%525, %530, %532) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %533 = "memref.extract_aligned_pointer_as_index"(%9) : (memref<memref<?x?x?xi32>>) -> index
//CHECK-NEXT:        %534 = arith.index_cast %533 : index to i64
//CHECK-NEXT:        %535 = "llvm.inttoptr"(%534) : (i64) -> !llvm.ptr
//CHECK-NEXT:        %536 = arith.constant 2 : i32
//CHECK-NEXT:        %537 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %536, %537[] : memref<i32>
//CHECK-NEXT:        %538 = arith.constant 3 : i32
//CHECK-NEXT:        %539 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %538, %539[] : memref<i32>
//CHECK-NEXT:        %540 = arith.constant 4 : i32
//CHECK-NEXT:        %541 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %540, %541[] : memref<i32>
//CHECK-NEXT:        %542 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %18, %542[] : memref<i32>
//CHECK-NEXT:        func.call @_QMpointers_testPmodify_3darray_ptr_one(%535, %537, %539, %541, %542) : (!llvm.ptr, memref<i32>, memref<i32>, memref<i32>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %543 = arith.constant 3 : index
//CHECK-NEXT:        %544 = memref.load %9[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %545 = memref.load %544[%543, %390, %20] : memref<?x?x?xi32>
//CHECK-NEXT:        %546 = arith.cmpi eq, %545, %18 : i32
//CHECK-NEXT:        %547 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %546, %547[] : memref<i1>
//CHECK-NEXT:        %548 = arith.constant {{.*}} : index
//CHECK-NEXT:        %549 = arith.index_cast %548 : index to i64
//CHECK-NEXT:        %550 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %551 = "llvm.insertvalue"(%550, %43) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %552 = "llvm.insertvalue"(%551, %549) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %553 = arith.constant 108 : i32
//CHECK-NEXT:        %554 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %553, %554[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%547, %552, %554) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMpointers_testPswap(%0 : !llvm.ptr {fir.bindc_name = "swp1"}, %1 : !llvm.ptr {fir.bindc_name = "swp2"}) {
//CHECK-NEXT:      %2 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %3 = "llvm.insertvalue"(%2, %0) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %4 = "llvm.insertvalue"(%3, %0) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %5 = arith.constant 0 : i64
//CHECK-NEXT:      %6 = "llvm.insertvalue"(%4, %5) <{position = array<i64: 2>}> : (!llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %7 = builtin.unrealized_conversion_cast %6 : !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)> to memref<memref<?xf32>>
//CHECK-NEXT:      %8 = "llvm.insertvalue"(%2, %1) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %9 = "llvm.insertvalue"(%8, %1) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %10 = "llvm.insertvalue"(%9, %5) <{position = array<i64: 2>}> : (!llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %11 = builtin.unrealized_conversion_cast %10 : !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)> to memref<memref<?xf32>>
//CHECK-NEXT:      %12 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %13 = memref.load %7[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %13, %12[] : memref<memref<?xf32>>
//CHECK-NEXT:      %14 = memref.load %11[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %14, %7[] : memref<memref<?xf32>>
//CHECK-NEXT:      %15 = memref.load %12[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %15, %11[] : memref<memref<?xf32>>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMpointers_testPmodify_array_ptr_one(%0 : !llvm.ptr {fir.bindc_name = "a"}, %1 : memref<i32> {fir.bindc_name = "idx"}, %2 : memref<f32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %3 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %4 = "llvm.insertvalue"(%3, %0) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %5 = "llvm.insertvalue"(%4, %0) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %6 = arith.constant 0 : i64
//CHECK-NEXT:      %7 = "llvm.insertvalue"(%5, %6) <{position = array<i64: 2>}> : (!llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %8 = builtin.unrealized_conversion_cast %7 : !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)> to memref<memref<?xf32>>
//CHECK-NEXT:      %9 = memref.load %2[] : memref<f32>
//CHECK-NEXT:      %10 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %11 = arith.extui %10 : i32 to i64
//CHECK-NEXT:      %12 = arith.index_cast %11 : i64 to index
//CHECK-NEXT:      %13 = arith.constant 1 : index
//CHECK-NEXT:      %14 = arith.subi %12, %13 : index
//CHECK-NEXT:      %15 = memref.load %8[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %9, %15[%14] : memref<?xf32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMpointers_testPmodify_3darray_ptr_one(%0 : !llvm.ptr {fir.bindc_name = "array"}, %1 : memref<i32> {fir.bindc_name = "k"}, %2 : memref<i32> {fir.bindc_name = "j"}, %3 : memref<i32> {fir.bindc_name = "i"}, %4 : memref<i32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %5 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %6 = "llvm.insertvalue"(%5, %0) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %7 = "llvm.insertvalue"(%6, %0) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %8 = arith.constant 0 : i64
//CHECK-NEXT:      %9 = "llvm.insertvalue"(%7, %8) <{position = array<i64: 2>}> : (!llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)>
//CHECK-NEXT:      %10 = builtin.unrealized_conversion_cast %9 : !llvm.struct<(!llvm.ptr, !llvm.ptr, i64)> to memref<memref<?x?x?xi32>>
//CHECK-NEXT:      %11 = memref.load %4[] : memref<i32>
//CHECK-NEXT:      %12 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %13 = arith.extui %12 : i32 to i64
//CHECK-NEXT:      %14 = arith.index_cast %13 : i64 to index
//CHECK-NEXT:      %15 = arith.constant 1 : index
//CHECK-NEXT:      %16 = arith.subi %14, %15 : index
//CHECK-NEXT:      %17 = memref.load %2[] : memref<i32>
//CHECK-NEXT:      %18 = arith.extui %17 : i32 to i64
//CHECK-NEXT:      %19 = arith.index_cast %18 : i64 to index
//CHECK-NEXT:      %20 = arith.subi %19, %15 : index
//CHECK-NEXT:      %21 = memref.load %3[] : memref<i32>
//CHECK-NEXT:      %22 = arith.extui %21 : i32 to i64
//CHECK-NEXT:      %23 = arith.index_cast %22 : i64 to index
//CHECK-NEXT:      %24 = arith.subi %23, %15 : index
//CHECK-NEXT:      %25 = memref.load %10[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:      memref.store %11, %25[%24, %20, %16] : memref<?x?x?xi32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    "memref.global"() <{sym_name = "_QMpointers_testFcalcEptr1", type = memref<memref<?xf32>>, initial_value, sym_visibility = "private"}> : () -> ()
//CHECK-NEXT:    "memref.global"() <{sym_name = "_QMpointers_testFcalcEptr2", type = memref<memref<?xf32>>, initial_value, sym_visibility = "private"}> : () -> ()
//CHECK-NEXT:    "memref.global"() <{sym_name = "_QMpointers_testFcalcEptr_md", type = memref<memref<?x?x?xi32>>, initial_value, sym_visibility = "private"}> : () -> ()
//CHECK-NEXT:    "llvm.mlir.global"() <{global_type = !llvm.array<{{[0-9]+}} x i8>, sym_name = "_{{.*}}", linkage = #llvm.linkage<"internal">, addr_space = 0 : i32, constant, value = "{{.*}}", unnamed_addr = 0 : i64}> ({
//CHECK-NEXT:    }) : () -> ()
//CHECK-NEXT:    func.func private @_QPassert(memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> () 
//CHECK-NEXT:    "llvm.mlir.global"() <{global_type = !llvm.array<{{[0-9]+}} x i8>, sym_name = "_{{.*}}", linkage = #llvm.linkage<"internal">, addr_space = 0 : i32, constant, value = "{{.*}}", unnamed_addr = 0 : i64}> ({
//CHECK-NEXT:    }) : () -> ()
//CHECK-NEXT:  }
//CHECK-EMPTY:  
