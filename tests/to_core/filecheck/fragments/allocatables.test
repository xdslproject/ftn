// RUN: xftn %S/../../../../examples/fragments/allocatables.F90 -DFRAGMENT_ONLY --stdout -t %S/tmp --cleanup --stages=flang,pre,ftn -v0 | FileCheck %s 
//CHECK:       builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.ident = "flang version 20.1.7 (https://github.com/llvm/llvm-project 6146a88f60492b520a36f8f8f3231e15f3cc6082)", llvm.target_triple = "x86_64-unknown-linux-gnu"} {
//CHECK-NEXT:    "memref.global"() <{sym_name = "_QMallocatables_testEglobal_array", type = memref<memref<?xf32>>, initial_value, sym_visibility = "private"}> : () -> ()
//CHECK-NEXT:    func.func @_QMallocatables_testPcalc() {
//CHECK-NEXT:      %0 = memref.get_global @_QMallocatables_testEglobal_array : memref<memref<?xf32>>
//CHECK-NEXT:      %1 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %2 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %3 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?x?x?xi32>>
//CHECK-NEXT:      %4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %5 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %6 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %7 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %8 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %9 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<memref<?xf32>>
//CHECK-NEXT:      %10 = arith.constant 100 : index
//CHECK-NEXT:      %11 = memref.alloc(%10) : memref<?xf32>
//CHECK-NEXT:      memref.store %11, %1[] : memref<memref<?xf32>>
//CHECK-NEXT:      %12 = memref.alloc(%10) : memref<?xf32>
//CHECK-NEXT:      memref.store %12, %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %13 = memref.alloc(%10) : memref<?xf32>
//CHECK-NEXT:      memref.store %13, %0[] : memref<memref<?xf32>>
//CHECK-NEXT:      %14 = arith.constant 10 : index
//CHECK-NEXT:      %15 = memref.alloc(%14, %14, %14) : memref<?x?x?xi32>
//CHECK-NEXT:      memref.store %15, %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:      %16 = memref.alloc(%14) : memref<?xf32>
//CHECK-NEXT:      memref.store %16, %9[] : memref<memref<?xf32>>
//CHECK-NEXT:      %17 = memref.alloc(%14) : memref<?xf32>
//CHECK-NEXT:      memref.store %17, %8[] : memref<memref<?xf32>>
//CHECK-NEXT:      %18 = memref.get_global @_QQro.10xr4.0 : memref<10xf32>
//CHECK-NEXT:      %19 = memref.load %9[] : memref<memref<?xf32>>
//CHECK-NEXT:      %20 = "memref.cast"(%18) : (memref<10xf32>) -> memref<?xf32>
//CHECK-NEXT:      "memref.copy"(%20, %19) : (memref<?xf32>, memref<?xf32>) -> ()
//CHECK-NEXT:      %21 = memref.get_global @_QQro.10xr4.1 : memref<10xf32>
//CHECK-NEXT:      %22 = memref.load %8[] : memref<memref<?xf32>>
//CHECK-NEXT:      %23 = "memref.cast"(%21) : (memref<10xf32>) -> memref<?xf32>
//CHECK-NEXT:      "memref.copy"(%23, %22) : (memref<?xf32>, memref<?xf32>) -> ()
//CHECK-NEXT:      %24 = arith.constant 1 : i32
//CHECK-NEXT:      %25 = arith.index_cast %24 : i32 to index
//CHECK-NEXT:      %26 = arith.constant 10 : i32
//CHECK-NEXT:      %27 = arith.index_cast %26 : i32 to index
//CHECK-NEXT:      %28 = arith.constant 1 : index
//CHECK-NEXT:      %29 = arith.index_cast %25 : index to i32
//CHECK-NEXT:      %30 = arith.addi %27, %28 : index
//CHECK-NEXT:      %31 = scf.for %32 = %25 to %30 step %28 iter_args(%33 = %29) -> (i32) {
//CHECK-NEXT:        memref.store %33, %4[] : memref<i32>
//CHECK-NEXT:        %34 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %35 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %36 = arith.extui %35 : i32 to i64
//CHECK-NEXT:          %37 = arith.index_cast %36 : i64 to index
//CHECK-NEXT:          %38 = arith.subi %37, %28 : index
//CHECK-NEXT:          %39 = memref.load %9[] : memref<memref<?xf32>>
//CHECK-NEXT:          %40 = memref.load %39[%38] : memref<?xf32>
//CHECK-NEXT:          %41 = arith.sitofp %35 : i32 to f32
//CHECK-NEXT:          %42 = arith.cmpf oeq, %40, %41 : f32
//CHECK-NEXT:          %43 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %42, %43[] : memref<i1>
//CHECK-NEXT:          %44 = arith.constant {{.*}} : index
//CHECK-NEXT:          %45 = arith.index_cast %44 : index to i64
//CHECK-NEXT:          %46 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %47 = "llvm.insertvalue"(%46, %34) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %48 = "llvm.insertvalue"(%47, %45) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %49 = arith.constant 23 : i32
//CHECK-NEXT:          %50 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %49, %50[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%43, %48, %50) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %51 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %52 = arith.extui %51 : i32 to i64
//CHECK-NEXT:          %53 = arith.index_cast %52 : i64 to index
//CHECK-NEXT:          %54 = arith.subi %53, %28 : index
//CHECK-NEXT:          %55 = memref.load %8[] : memref<memref<?xf32>>
//CHECK-NEXT:          %56 = memref.load %55[%54] : memref<?xf32>
//CHECK-NEXT:          %57 = arith.addi %51, %26 : i32
//CHECK-NEXT:          %58 = arith.sitofp %57 : i32 to f32
//CHECK-NEXT:          %59 = arith.cmpf oeq, %56, %58 : f32
//CHECK-NEXT:          %60 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %59, %60[] : memref<i1>
//CHECK-NEXT:          %61 = arith.constant {{.*}} : index
//CHECK-NEXT:          %62 = arith.index_cast %61 : index to i64
//CHECK-NEXT:          %63 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %64 = "llvm.insertvalue"(%63, %34) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %65 = "llvm.insertvalue"(%64, %62) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %66 = arith.constant 24 : i32
//CHECK-NEXT:          %67 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %66, %67[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%60, %65, %67) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %68 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %69 = arith.index_cast %28 : index to i32
//CHECK-NEXT:        %70 = arith.addi %68, %69 : i32
//CHECK-NEXT:        scf.yield %70 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %31, %4[] : memref<i32>
//CHECK-NEXT:      %71 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %72 = arith.constant true
//CHECK-NEXT:        %73 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %72, %73[] : memref<i1>
//CHECK-NEXT:        %74 = arith.constant {{.*}} : index
//CHECK-NEXT:        %75 = arith.index_cast %74 : index to i64
//CHECK-NEXT:        %76 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %77 = "llvm.insertvalue"(%76, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %78 = "llvm.insertvalue"(%77, %75) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %79 = arith.constant 28 : i32
//CHECK-NEXT:        %80 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %79, %80[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%73, %78, %80) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %81 = arith.constant true
//CHECK-NEXT:        %82 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %81, %82[] : memref<i1>
//CHECK-NEXT:        %83 = arith.constant {{.*}} : index
//CHECK-NEXT:        %84 = arith.index_cast %83 : index to i64
//CHECK-NEXT:        %85 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %86 = "llvm.insertvalue"(%85, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %87 = "llvm.insertvalue"(%86, %84) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %88 = arith.constant 29 : i32
//CHECK-NEXT:        %89 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %88, %89[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%82, %87, %89) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %90 = arith.constant true
//CHECK-NEXT:        %91 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %90, %91[] : memref<i1>
//CHECK-NEXT:        %92 = arith.constant {{.*}} : index
//CHECK-NEXT:        %93 = arith.index_cast %92 : index to i64
//CHECK-NEXT:        %94 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %95 = "llvm.insertvalue"(%94, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %96 = "llvm.insertvalue"(%95, %93) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %97 = arith.constant 30 : i32
//CHECK-NEXT:        %98 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %97, %98[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%91, %96, %98) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %99 = arith.constant true
//CHECK-NEXT:        %100 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %99, %100[] : memref<i1>
//CHECK-NEXT:        %101 = arith.constant {{.*}} : index
//CHECK-NEXT:        %102 = arith.index_cast %101 : index to i64
//CHECK-NEXT:        %103 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %104 = "llvm.insertvalue"(%103, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %105 = "llvm.insertvalue"(%104, %102) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %106 = arith.constant 31 : i32
//CHECK-NEXT:        %107 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %106, %107[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%100, %105, %107) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %108 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:        %109 = arith.constant 0 : index
//CHECK-NEXT:        %110 = "memref.dim"(%108, %109) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %111 = arith.index_cast %110 : index to i64
//CHECK-NEXT:        %112 = arith.trunci %111 : i64 to i32
//CHECK-NEXT:        %113 = arith.constant 100 : i32
//CHECK-NEXT:        %114 = arith.cmpi eq, %112, %113 : i32
//CHECK-NEXT:        %115 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %114, %115[] : memref<i1>
//CHECK-NEXT:        %116 = arith.constant {{.*}} : index
//CHECK-NEXT:        %117 = arith.index_cast %116 : index to i64
//CHECK-NEXT:        %118 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %119 = "llvm.insertvalue"(%118, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %120 = "llvm.insertvalue"(%119, %117) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %121 = arith.constant 34 : i32
//CHECK-NEXT:        %122 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %121, %122[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%115, %120, %122) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %123 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:        %124 = arith.constant 0 : index
//CHECK-NEXT:        %125 = "memref.dim"(%123, %124) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %126 = arith.index_cast %125 : index to i64
//CHECK-NEXT:        %127 = arith.trunci %126 : i64 to i32
//CHECK-NEXT:        %128 = arith.constant 100 : i32
//CHECK-NEXT:        %129 = arith.cmpi eq, %127, %128 : i32
//CHECK-NEXT:        %130 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %129, %130[] : memref<i1>
//CHECK-NEXT:        %131 = arith.constant {{.*}} : index
//CHECK-NEXT:        %132 = arith.index_cast %131 : index to i64
//CHECK-NEXT:        %133 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %134 = "llvm.insertvalue"(%133, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %135 = "llvm.insertvalue"(%134, %132) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %136 = arith.constant 35 : i32
//CHECK-NEXT:        %137 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %136, %137[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%130, %135, %137) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %138 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:        %139 = arith.constant 0 : index
//CHECK-NEXT:        %140 = "memref.dim"(%138, %139) : (memref<?xf32>, index) -> index
//CHECK-NEXT:        %141 = arith.index_cast %140 : index to i64
//CHECK-NEXT:        %142 = arith.trunci %141 : i64 to i32
//CHECK-NEXT:        %143 = arith.constant 100 : i32
//CHECK-NEXT:        %144 = arith.cmpi eq, %142, %143 : i32
//CHECK-NEXT:        %145 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %144, %145[] : memref<i1>
//CHECK-NEXT:        %146 = arith.constant {{.*}} : index
//CHECK-NEXT:        %147 = arith.index_cast %146 : index to i64
//CHECK-NEXT:        %148 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %149 = "llvm.insertvalue"(%148, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %150 = "llvm.insertvalue"(%149, %147) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %151 = arith.constant 36 : i32
//CHECK-NEXT:        %152 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %151, %152[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%145, %150, %152) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %153 = memref.load %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %154 = arith.constant 0 : index
//CHECK-NEXT:        %155 = "memref.dim"(%153, %154) : (memref<?x?x?xi32>, index) -> index
//CHECK-NEXT:        %156 = arith.index_cast %155 : index to i64
//CHECK-NEXT:        %157 = "memref.dim"(%153, %28) : (memref<?x?x?xi32>, index) -> index
//CHECK-NEXT:        %158 = arith.index_cast %157 : index to i64
//CHECK-NEXT:        %159 = arith.muli %156, %158 : i64
//CHECK-NEXT:        %160 = arith.constant 2 : index
//CHECK-NEXT:        %161 = "memref.dim"(%153, %160) : (memref<?x?x?xi32>, index) -> index
//CHECK-NEXT:        %162 = arith.index_cast %161 : index to i64
//CHECK-NEXT:        %163 = arith.muli %159, %162 : i64
//CHECK-NEXT:        %164 = arith.trunci %163 : i64 to i32
//CHECK-NEXT:        %165 = arith.constant 1000 : i32
//CHECK-NEXT:        %166 = arith.cmpi eq, %164, %165 : i32
//CHECK-NEXT:        %167 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %166, %167[] : memref<i1>
//CHECK-NEXT:        %168 = arith.constant {{.*}} : index
//CHECK-NEXT:        %169 = arith.index_cast %168 : index to i64
//CHECK-NEXT:        %170 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %171 = "llvm.insertvalue"(%170, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %172 = "llvm.insertvalue"(%171, %169) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %173 = arith.constant 37 : i32
//CHECK-NEXT:        %174 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %173, %174[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%167, %172, %174) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %175 = memref.load %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %176 = "memref.dim"(%175, %28) : (memref<?x?x?xi32>, index) -> index
//CHECK-NEXT:        %177 = arith.index_cast %176 : index to i64
//CHECK-NEXT:        %178 = arith.trunci %177 : i64 to i32
//CHECK-NEXT:        %179 = arith.cmpi eq, %178, %26 : i32
//CHECK-NEXT:        %180 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %179, %180[] : memref<i1>
//CHECK-NEXT:        %181 = arith.constant {{.*}} : index
//CHECK-NEXT:        %182 = arith.index_cast %181 : index to i64
//CHECK-NEXT:        %183 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %184 = "llvm.insertvalue"(%183, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %185 = "llvm.insertvalue"(%184, %182) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %186 = arith.constant 38 : i32
//CHECK-NEXT:        %187 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %186, %187[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%180, %185, %187) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %188 = arith.constant 100 : i32
//CHECK-NEXT:      %189 = arith.index_cast %188 : i32 to index
//CHECK-NEXT:      %190 = arith.addi %189, %28 : index
//CHECK-NEXT:      %191 = scf.for %192 = %25 to %190 step %28 iter_args(%193 = %29) -> (i32) {
//CHECK-NEXT:        memref.store %193, %4[] : memref<i32>
//CHECK-NEXT:        %194 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %195 = arith.sitofp %194 : i32 to f32
//CHECK-NEXT:        %196 = arith.extui %194 : i32 to i64
//CHECK-NEXT:        %197 = arith.index_cast %196 : i64 to index
//CHECK-NEXT:        %198 = arith.subi %197, %28 : index
//CHECK-NEXT:        %199 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:        memref.store %195, %199[%198] : memref<?xf32>
//CHECK-NEXT:        %200 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %201 = arith.subi %188, %200 : i32
//CHECK-NEXT:        %202 = arith.sitofp %201 : i32 to f32
//CHECK-NEXT:        %203 = arith.extui %200 : i32 to i64
//CHECK-NEXT:        %204 = arith.index_cast %203 : i64 to index
//CHECK-NEXT:        %205 = arith.subi %204, %28 : index
//CHECK-NEXT:        %206 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:        memref.store %202, %206[%205] : memref<?xf32>
//CHECK-NEXT:        %207 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %208 = arith.muli %207, %26 : i32
//CHECK-NEXT:        %209 = arith.sitofp %208 : i32 to f32
//CHECK-NEXT:        %210 = arith.extui %207 : i32 to i64
//CHECK-NEXT:        %211 = arith.index_cast %210 : i64 to index
//CHECK-NEXT:        %212 = arith.subi %211, %28 : index
//CHECK-NEXT:        %213 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:        memref.store %209, %213[%212] : memref<?xf32>
//CHECK-NEXT:        %214 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %215 = arith.index_cast %28 : index to i32
//CHECK-NEXT:        %216 = arith.addi %214, %215 : i32
//CHECK-NEXT:        scf.yield %216 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %191, %4[] : memref<i32>
//CHECK-NEXT:      %217 = scf.for %218 = %25 to %190 step %28 iter_args(%219 = %29) -> (i32) {
//CHECK-NEXT:        memref.store %219, %4[] : memref<i32>
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %220 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %221 = arith.extui %220 : i32 to i64
//CHECK-NEXT:          %222 = arith.index_cast %221 : i64 to index
//CHECK-NEXT:          %223 = arith.subi %222, %28 : index
//CHECK-NEXT:          %224 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:          %225 = memref.load %224[%223] : memref<?xf32>
//CHECK-NEXT:          %226 = arith.sitofp %220 : i32 to f32
//CHECK-NEXT:          %227 = arith.cmpf oeq, %225, %226 : f32
//CHECK-NEXT:          %228 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %227, %228[] : memref<i1>
//CHECK-NEXT:          %229 = arith.constant {{.*}} : index
//CHECK-NEXT:          %230 = arith.index_cast %229 : index to i64
//CHECK-NEXT:          %231 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %232 = "llvm.insertvalue"(%231, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %233 = "llvm.insertvalue"(%232, %230) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %234 = arith.constant 48 : i32
//CHECK-NEXT:          %235 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %234, %235[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%228, %233, %235) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %236 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %237 = arith.extui %236 : i32 to i64
//CHECK-NEXT:          %238 = arith.index_cast %237 : i64 to index
//CHECK-NEXT:          %239 = arith.subi %238, %28 : index
//CHECK-NEXT:          %240 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:          %241 = memref.load %240[%239] : memref<?xf32>
//CHECK-NEXT:          %242 = arith.subi %188, %236 : i32
//CHECK-NEXT:          %243 = arith.sitofp %242 : i32 to f32
//CHECK-NEXT:          %244 = arith.cmpf oeq, %241, %243 : f32
//CHECK-NEXT:          %245 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %244, %245[] : memref<i1>
//CHECK-NEXT:          %246 = arith.constant {{.*}} : index
//CHECK-NEXT:          %247 = arith.index_cast %246 : index to i64
//CHECK-NEXT:          %248 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %249 = "llvm.insertvalue"(%248, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %250 = "llvm.insertvalue"(%249, %247) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %251 = arith.constant 49 : i32
//CHECK-NEXT:          %252 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %251, %252[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%245, %250, %252) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %253 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %254 = arith.extui %253 : i32 to i64
//CHECK-NEXT:          %255 = arith.index_cast %254 : i64 to index
//CHECK-NEXT:          %256 = arith.subi %255, %28 : index
//CHECK-NEXT:          %257 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:          %258 = memref.load %257[%256] : memref<?xf32>
//CHECK-NEXT:          %259 = arith.muli %253, %26 : i32
//CHECK-NEXT:          %260 = arith.sitofp %259 : i32 to f32
//CHECK-NEXT:          %261 = arith.cmpf oeq, %258, %260 : f32
//CHECK-NEXT:          %262 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %261, %262[] : memref<i1>
//CHECK-NEXT:          %263 = arith.constant {{.*}} : index
//CHECK-NEXT:          %264 = arith.index_cast %263 : index to i64
//CHECK-NEXT:          %265 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %266 = "llvm.insertvalue"(%265, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %267 = "llvm.insertvalue"(%266, %264) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %268 = arith.constant 50 : i32
//CHECK-NEXT:          %269 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %268, %269[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%262, %267, %269) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %270 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %271 = arith.index_cast %28 : index to i32
//CHECK-NEXT:        %272 = arith.addi %270, %271 : i32
//CHECK-NEXT:        scf.yield %272 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %217, %4[] : memref<i32>
//CHECK-NEXT:      %273 = arith.constant 3.450000e+01 : f32
//CHECK-NEXT:      %274 = arith.constant 19 : index
//CHECK-NEXT:      %275 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %273, %275[%274] : memref<?xf32>
//CHECK-NEXT:      %276 = arith.constant 1.652000e+02 : f32
//CHECK-NEXT:      %277 = arith.constant 49 : index
//CHECK-NEXT:      %278 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %276, %278[%277] : memref<?xf32>
//CHECK-NEXT:      %279 = arith.constant 2.310000e+01 : f32
//CHECK-NEXT:      %280 = arith.constant 69 : index
//CHECK-NEXT:      %281 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %279, %281[%280] : memref<?xf32>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %282 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:        %283 = memref.load %282[%274] : memref<?xf32>
//CHECK-NEXT:        %284 = arith.cmpf oeq, %283, %273 : f32
//CHECK-NEXT:        %285 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %284, %285[] : memref<i1>
//CHECK-NEXT:        %286 = arith.constant {{.*}} : index
//CHECK-NEXT:        %287 = arith.index_cast %286 : index to i64
//CHECK-NEXT:        %288 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %289 = "llvm.insertvalue"(%288, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %290 = "llvm.insertvalue"(%289, %287) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %291 = arith.constant 57 : i32
//CHECK-NEXT:        %292 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %291, %292[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%285, %290, %292) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %293 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:        %294 = memref.load %293[%277] : memref<?xf32>
//CHECK-NEXT:        %295 = arith.cmpf oeq, %294, %276 : f32
//CHECK-NEXT:        %296 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %295, %296[] : memref<i1>
//CHECK-NEXT:        %297 = arith.constant {{.*}} : index
//CHECK-NEXT:        %298 = arith.index_cast %297 : index to i64
//CHECK-NEXT:        %299 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %300 = "llvm.insertvalue"(%299, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %301 = "llvm.insertvalue"(%300, %298) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %302 = arith.constant 58 : i32
//CHECK-NEXT:        %303 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %302, %303[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%296, %301, %303) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %304 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:        %305 = memref.load %304[%280] : memref<?xf32>
//CHECK-NEXT:        %306 = arith.cmpf oeq, %305, %279 : f32
//CHECK-NEXT:        %307 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %306, %307[] : memref<i1>
//CHECK-NEXT:        %308 = arith.constant {{.*}} : index
//CHECK-NEXT:        %309 = arith.index_cast %308 : index to i64
//CHECK-NEXT:        %310 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %311 = "llvm.insertvalue"(%310, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %312 = "llvm.insertvalue"(%311, %309) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %313 = arith.constant 59 : i32
//CHECK-NEXT:        %314 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %313, %314[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%307, %312, %314) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %315 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:        %316 = arith.constant 20 : i32
//CHECK-NEXT:        %317 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %316, %317[] : memref<i32>
//CHECK-NEXT:        %318 = arith.constant 2.000000e+01 : f32
//CHECK-NEXT:        %319 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %318, %319[] : memref<f32>
//CHECK-NEXT:        func.call @_QMallocatables_testPmodify_array_one(%315, %317, %319) : (memref<?xf32>, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %320 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:        %321 = "memref.cast"(%320) : (memref<?xf32>) -> memref<100xf32>
//CHECK-NEXT:        %322 = arith.constant 50 : i32
//CHECK-NEXT:        %323 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %322, %323[] : memref<i32>
//CHECK-NEXT:        %324 = arith.constant 5.000000e+01 : f32
//CHECK-NEXT:        %325 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %324, %325[] : memref<f32>
//CHECK-NEXT:        func.call @_QMallocatables_testPmodify_array_two(%321, %323, %325) : (memref<100xf32>, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %326 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:        %327 = "memref.cast"(%326) : (memref<?xf32>) -> memref<100xf32>
//CHECK-NEXT:        %328 = arith.constant 70 : i32
//CHECK-NEXT:        %329 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %328, %329[] : memref<i32>
//CHECK-NEXT:        %330 = arith.constant 7.000000e+02 : f32
//CHECK-NEXT:        %331 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %330, %331[] : memref<f32>
//CHECK-NEXT:        func.call @_QMallocatables_testPmodify_array_two(%327, %329, %331) : (memref<100xf32>, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %332 = scf.for %333 = %25 to %190 step %28 iter_args(%334 = %29) -> (i32) {
//CHECK-NEXT:        memref.store %334, %4[] : memref<i32>
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %335 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %336 = arith.extui %335 : i32 to i64
//CHECK-NEXT:          %337 = arith.index_cast %336 : i64 to index
//CHECK-NEXT:          %338 = arith.subi %337, %28 : index
//CHECK-NEXT:          %339 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:          %340 = memref.load %339[%338] : memref<?xf32>
//CHECK-NEXT:          %341 = arith.sitofp %335 : i32 to f32
//CHECK-NEXT:          %342 = arith.cmpf oeq, %340, %341 : f32
//CHECK-NEXT:          %343 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %342, %343[] : memref<i1>
//CHECK-NEXT:          %344 = arith.constant {{.*}} : index
//CHECK-NEXT:          %345 = arith.index_cast %344 : index to i64
//CHECK-NEXT:          %346 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %347 = "llvm.insertvalue"(%346, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %348 = "llvm.insertvalue"(%347, %345) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %349 = arith.constant 69 : i32
//CHECK-NEXT:          %350 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %349, %350[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%343, %348, %350) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %351 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %352 = arith.extui %351 : i32 to i64
//CHECK-NEXT:          %353 = arith.index_cast %352 : i64 to index
//CHECK-NEXT:          %354 = arith.subi %353, %28 : index
//CHECK-NEXT:          %355 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:          %356 = memref.load %355[%354] : memref<?xf32>
//CHECK-NEXT:          %357 = arith.subi %188, %351 : i32
//CHECK-NEXT:          %358 = arith.sitofp %357 : i32 to f32
//CHECK-NEXT:          %359 = arith.cmpf oeq, %356, %358 : f32
//CHECK-NEXT:          %360 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %359, %360[] : memref<i1>
//CHECK-NEXT:          %361 = arith.constant {{.*}} : index
//CHECK-NEXT:          %362 = arith.index_cast %361 : index to i64
//CHECK-NEXT:          %363 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %364 = "llvm.insertvalue"(%363, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %365 = "llvm.insertvalue"(%364, %362) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %366 = arith.constant 70 : i32
//CHECK-NEXT:          %367 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %366, %367[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%360, %365, %367) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %368 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %369 = arith.extui %368 : i32 to i64
//CHECK-NEXT:          %370 = arith.index_cast %369 : i64 to index
//CHECK-NEXT:          %371 = arith.subi %370, %28 : index
//CHECK-NEXT:          %372 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:          %373 = memref.load %372[%371] : memref<?xf32>
//CHECK-NEXT:          %374 = arith.muli %368, %26 : i32
//CHECK-NEXT:          %375 = arith.sitofp %374 : i32 to f32
//CHECK-NEXT:          %376 = arith.cmpf oeq, %373, %375 : f32
//CHECK-NEXT:          %377 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %376, %377[] : memref<i1>
//CHECK-NEXT:          %378 = arith.constant {{.*}} : index
//CHECK-NEXT:          %379 = arith.index_cast %378 : index to i64
//CHECK-NEXT:          %380 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %381 = "llvm.insertvalue"(%380, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %382 = "llvm.insertvalue"(%381, %379) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %383 = arith.constant 71 : i32
//CHECK-NEXT:          %384 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %383, %384[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%377, %382, %384) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %385 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %386 = arith.index_cast %28 : index to i32
//CHECK-NEXT:        %387 = arith.addi %385, %386 : i32
//CHECK-NEXT:        scf.yield %387 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %332, %4[] : memref<i32>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %388 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:        %389 = arith.constant 60 : i32
//CHECK-NEXT:        %390 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %389, %390[] : memref<i32>
//CHECK-NEXT:        %391 = arith.constant 1.234000e+02 : f32
//CHECK-NEXT:        %392 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %391, %392[] : memref<f32>
//CHECK-NEXT:        func.call @_QMallocatables_testPmodify_array_one(%388, %390, %392) : (memref<?xf32>, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %393 = arith.constant 59 : index
//CHECK-NEXT:        %394 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:        %395 = memref.load %394[%393] : memref<?xf32>
//CHECK-NEXT:        %396 = arith.constant 1.234000e+02 : f32
//CHECK-NEXT:        %397 = arith.cmpf oeq, %395, %396 : f32
//CHECK-NEXT:        %398 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %397, %398[] : memref<i1>
//CHECK-NEXT:        %399 = arith.constant {{.*}} : index
//CHECK-NEXT:        %400 = arith.index_cast %399 : index to i64
//CHECK-NEXT:        %401 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %402 = "llvm.insertvalue"(%401, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %403 = "llvm.insertvalue"(%402, %400) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %404 = arith.constant 75 : i32
//CHECK-NEXT:        %405 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %404, %405[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%398, %403, %405) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %406 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %406, %7[] : memref<memref<?xf32>>
//CHECK-NEXT:      %407 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %407, %1[] : memref<memref<?xf32>>
//CHECK-NEXT:      %408 = memref.load %7[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %408, %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %409 = scf.for %410 = %25 to %190 step %28 iter_args(%411 = %29) -> (i32) {
//CHECK-NEXT:        memref.store %411, %4[] : memref<i32>
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %412 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %413 = arith.extui %412 : i32 to i64
//CHECK-NEXT:          %414 = arith.index_cast %413 : i64 to index
//CHECK-NEXT:          %415 = arith.subi %414, %28 : index
//CHECK-NEXT:          %416 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:          %417 = memref.load %416[%415] : memref<?xf32>
//CHECK-NEXT:          %418 = arith.sitofp %412 : i32 to f32
//CHECK-NEXT:          %419 = arith.cmpf oeq, %417, %418 : f32
//CHECK-NEXT:          %420 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %419, %420[] : memref<i1>
//CHECK-NEXT:          %421 = arith.constant {{.*}} : index
//CHECK-NEXT:          %422 = arith.index_cast %421 : index to i64
//CHECK-NEXT:          %423 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %424 = "llvm.insertvalue"(%423, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %425 = "llvm.insertvalue"(%424, %422) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %426 = arith.constant 83 : i32
//CHECK-NEXT:          %427 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %426, %427[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%420, %425, %427) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %428 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %429 = arith.extui %428 : i32 to i64
//CHECK-NEXT:          %430 = arith.index_cast %429 : i64 to index
//CHECK-NEXT:          %431 = arith.subi %430, %28 : index
//CHECK-NEXT:          %432 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:          %433 = memref.load %432[%431] : memref<?xf32>
//CHECK-NEXT:          %434 = arith.subi %188, %428 : i32
//CHECK-NEXT:          %435 = arith.sitofp %434 : i32 to f32
//CHECK-NEXT:          %436 = arith.cmpf oeq, %433, %435 : f32
//CHECK-NEXT:          %437 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %436, %437[] : memref<i1>
//CHECK-NEXT:          %438 = arith.constant {{.*}} : index
//CHECK-NEXT:          %439 = arith.index_cast %438 : index to i64
//CHECK-NEXT:          %440 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %441 = "llvm.insertvalue"(%440, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %442 = "llvm.insertvalue"(%441, %439) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %443 = arith.constant 84 : i32
//CHECK-NEXT:          %444 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %443, %444[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%437, %442, %444) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %445 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %446 = arith.index_cast %28 : index to i32
//CHECK-NEXT:        %447 = arith.addi %445, %446 : i32
//CHECK-NEXT:        scf.yield %447 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %409, %4[] : memref<i32>
//CHECK-NEXT:      %448 = arith.constant 6.000000e+02 : f32
//CHECK-NEXT:      %449 = arith.constant 59 : index
//CHECK-NEXT:      %450 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %448, %450[%449] : memref<?xf32>
//CHECK-NEXT:      %451 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      %452 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:      "memref.copy"(%451, %452) : (memref<?xf32>, memref<?xf32>) -> ()
//CHECK-NEXT:      %453 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:      %454 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      "memref.copy"(%453, %454) : (memref<?xf32>, memref<?xf32>) -> ()
//CHECK-NEXT:      %455 = scf.for %456 = %25 to %190 step %28 iter_args(%457 = %29) -> (i32) {
//CHECK-NEXT:        memref.store %457, %4[] : memref<i32>
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %458 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %459 = arith.extui %458 : i32 to i64
//CHECK-NEXT:          %460 = arith.index_cast %459 : i64 to index
//CHECK-NEXT:          %461 = arith.subi %460, %28 : index
//CHECK-NEXT:          %462 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:          %463 = memref.load %462[%461] : memref<?xf32>
//CHECK-NEXT:          %464 = arith.sitofp %458 : i32 to f32
//CHECK-NEXT:          %465 = arith.cmpf oeq, %463, %464 : f32
//CHECK-NEXT:          %466 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %465, %466[] : memref<i1>
//CHECK-NEXT:          %467 = arith.constant {{.*}} : index
//CHECK-NEXT:          %468 = arith.index_cast %467 : index to i64
//CHECK-NEXT:          %469 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %470 = "llvm.insertvalue"(%469, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %471 = "llvm.insertvalue"(%470, %468) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %472 = arith.constant 94 : i32
//CHECK-NEXT:          %473 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %472, %473[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%466, %471, %473) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %474 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %475 = arith.extui %474 : i32 to i64
//CHECK-NEXT:          %476 = arith.index_cast %475 : i64 to index
//CHECK-NEXT:          %477 = arith.subi %476, %28 : index
//CHECK-NEXT:          %478 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:          %479 = memref.load %478[%477] : memref<?xf32>
//CHECK-NEXT:          %480 = arith.muli %474, %26 : i32
//CHECK-NEXT:          %481 = arith.sitofp %480 : i32 to f32
//CHECK-NEXT:          %482 = arith.cmpf oeq, %479, %481 : f32
//CHECK-NEXT:          %483 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %482, %483[] : memref<i1>
//CHECK-NEXT:          %484 = arith.constant {{.*}} : index
//CHECK-NEXT:          %485 = arith.index_cast %484 : index to i64
//CHECK-NEXT:          %486 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %487 = "llvm.insertvalue"(%486, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %488 = "llvm.insertvalue"(%487, %485) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %489 = arith.constant 95 : i32
//CHECK-NEXT:          %490 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %489, %490[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%483, %488, %490) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %491 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %492 = arith.index_cast %28 : index to i32
//CHECK-NEXT:        %493 = arith.addi %491, %492 : i32
//CHECK-NEXT:        scf.yield %493 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %455, %4[] : memref<i32>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %494 = arith.constant 80 : i32
//CHECK-NEXT:        %495 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %494, %495[] : memref<i32>
//CHECK-NEXT:        %496 = arith.constant 1.340000e+01 : f32
//CHECK-NEXT:        %497 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %496, %497[] : memref<f32>
//CHECK-NEXT:        func.call @_QMallocatables_testPmodify_array_three(%1, %495, %497) : (memref<memref<?xf32>>, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %498 = arith.constant 79 : index
//CHECK-NEXT:        %499 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:        %500 = memref.load %499[%498] : memref<?xf32>
//CHECK-NEXT:        %501 = arith.constant 1.340000e+01 : f32
//CHECK-NEXT:        %502 = arith.cmpf oeq, %500, %501 : f32
//CHECK-NEXT:        %503 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %502, %503[] : memref<i1>
//CHECK-NEXT:        %504 = arith.constant {{.*}} : index
//CHECK-NEXT:        %505 = arith.index_cast %504 : index to i64
//CHECK-NEXT:        %506 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %507 = "llvm.insertvalue"(%506, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %508 = "llvm.insertvalue"(%507, %505) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %509 = arith.constant 99 : i32
//CHECK-NEXT:        %510 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %509, %510[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%503, %508, %510) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %511 = scf.for %512 = %25 to %30 step %28 iter_args(%513 = %29) -> (i32) {
//CHECK-NEXT:        memref.store %513, %4[] : memref<i32>
//CHECK-NEXT:        %514 = scf.for %515 = %25 to %30 step %28 iter_args(%516 = %29) -> (i32) {
//CHECK-NEXT:          memref.store %516, %5[] : memref<i32>
//CHECK-NEXT:          %517 = scf.for %518 = %25 to %30 step %28 iter_args(%519 = %29) -> (i32) {
//CHECK-NEXT:            memref.store %519, %6[] : memref<i32>
//CHECK-NEXT:            %520 = memref.load %6[] : memref<i32>
//CHECK-NEXT:            %521 = memref.load %5[] : memref<i32>
//CHECK-NEXT:            %522 = arith.muli %521, %26 : i32
//CHECK-NEXT:            %523 = arith.addi %520, %522 : i32
//CHECK-NEXT:            %524 = memref.load %4[] : memref<i32>
//CHECK-NEXT:            %525 = arith.muli %524, %188 : i32
//CHECK-NEXT:            %526 = arith.addi %523, %525 : i32
//CHECK-NEXT:            %527 = arith.extui %520 : i32 to i64
//CHECK-NEXT:            %528 = arith.index_cast %527 : i64 to index
//CHECK-NEXT:            %529 = arith.subi %528, %28 : index
//CHECK-NEXT:            %530 = arith.extui %521 : i32 to i64
//CHECK-NEXT:            %531 = arith.index_cast %530 : i64 to index
//CHECK-NEXT:            %532 = arith.subi %531, %28 : index
//CHECK-NEXT:            %533 = arith.extui %524 : i32 to i64
//CHECK-NEXT:            %534 = arith.index_cast %533 : i64 to index
//CHECK-NEXT:            %535 = arith.subi %534, %28 : index
//CHECK-NEXT:            %536 = memref.load %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:            memref.store %526, %536[%535, %532, %529] : memref<?x?x?xi32>
//CHECK-NEXT:            %537 = memref.load %6[] : memref<i32>
//CHECK-NEXT:            %538 = arith.index_cast %28 : index to i32
//CHECK-NEXT:            %539 = arith.addi %537, %538 : i32
//CHECK-NEXT:            scf.yield %539 : i32
//CHECK-NEXT:          }
//CHECK-NEXT:          memref.store %517, %6[] : memref<i32>
//CHECK-NEXT:          %540 = memref.load %5[] : memref<i32>
//CHECK-NEXT:          %541 = arith.index_cast %28 : index to i32
//CHECK-NEXT:          %542 = arith.addi %540, %541 : i32
//CHECK-NEXT:          scf.yield %542 : i32
//CHECK-NEXT:        }
//CHECK-NEXT:        memref.store %514, %5[] : memref<i32>
//CHECK-NEXT:        %543 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %544 = arith.index_cast %28 : index to i32
//CHECK-NEXT:        %545 = arith.addi %543, %544 : i32
//CHECK-NEXT:        scf.yield %545 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %511, %4[] : memref<i32>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %546 = arith.constant 2 : index
//CHECK-NEXT:        %547 = arith.constant 3 : index
//CHECK-NEXT:        %548 = arith.constant 4 : index
//CHECK-NEXT:        %549 = memref.load %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %550 = memref.load %549[%548, %547, %546] : memref<?x?x?xi32>
//CHECK-NEXT:        %551 = arith.constant 543 : i32
//CHECK-NEXT:        %552 = arith.cmpi eq, %550, %551 : i32
//CHECK-NEXT:        %553 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %552, %553[] : memref<i1>
//CHECK-NEXT:        %554 = arith.constant {{.*}} : index
//CHECK-NEXT:        %555 = arith.index_cast %554 : index to i64
//CHECK-NEXT:        %556 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %557 = "llvm.insertvalue"(%556, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %558 = "llvm.insertvalue"(%557, %555) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %559 = arith.constant 109 : i32
//CHECK-NEXT:        %560 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %559, %560[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%553, %558, %560) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %561 = arith.constant 7 : index
//CHECK-NEXT:        %562 = arith.constant 8 : index
//CHECK-NEXT:        %563 = arith.constant 0 : index
//CHECK-NEXT:        %564 = memref.load %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %565 = memref.load %564[%563, %562, %561] : memref<?x?x?xi32>
//CHECK-NEXT:        %566 = arith.constant 198 : i32
//CHECK-NEXT:        %567 = arith.cmpi eq, %565, %566 : i32
//CHECK-NEXT:        %568 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %567, %568[] : memref<i1>
//CHECK-NEXT:        %569 = arith.constant {{.*}} : index
//CHECK-NEXT:        %570 = arith.index_cast %569 : index to i64
//CHECK-NEXT:        %571 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %572 = "llvm.insertvalue"(%571, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %573 = "llvm.insertvalue"(%572, %570) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %574 = arith.constant 110 : i32
//CHECK-NEXT:        %575 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %574, %575[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%568, %573, %575) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %576 = memref.load %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %577 = arith.constant 2 : i32
//CHECK-NEXT:        %578 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %577, %578[] : memref<i32>
//CHECK-NEXT:        %579 = arith.constant 3 : i32
//CHECK-NEXT:        %580 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %579, %580[] : memref<i32>
//CHECK-NEXT:        %581 = arith.constant 4 : i32
//CHECK-NEXT:        %582 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %581, %582[] : memref<i32>
//CHECK-NEXT:        %583 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %188, %583[] : memref<i32>
//CHECK-NEXT:        func.call @_QMallocatables_testPmodify_3darray_one(%576, %578, %580, %582, %583) : (memref<?x?x?xi32>, memref<i32>, memref<i32>, memref<i32>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %584 = arith.constant 2 : index
//CHECK-NEXT:        %585 = arith.constant 3 : index
//CHECK-NEXT:        %586 = memref.load %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %587 = memref.load %586[%585, %584, %28] : memref<?x?x?xi32>
//CHECK-NEXT:        %588 = arith.cmpi eq, %587, %188 : i32
//CHECK-NEXT:        %589 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %588, %589[] : memref<i1>
//CHECK-NEXT:        %590 = arith.constant {{.*}} : index
//CHECK-NEXT:        %591 = arith.index_cast %590 : index to i64
//CHECK-NEXT:        %592 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %593 = "llvm.insertvalue"(%592, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %594 = "llvm.insertvalue"(%593, %591) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %595 = arith.constant 113 : i32
//CHECK-NEXT:        %596 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %595, %596[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%589, %594, %596) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %597 = memref.load %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %598 = "memref.cast"(%597) : (memref<?x?x?xi32>) -> memref<10x10x10xi32>
//CHECK-NEXT:        %599 = arith.constant 6 : i32
//CHECK-NEXT:        %600 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %599, %600[] : memref<i32>
//CHECK-NEXT:        %601 = arith.constant 7 : i32
//CHECK-NEXT:        %602 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %601, %602[] : memref<i32>
//CHECK-NEXT:        %603 = arith.constant 8 : i32
//CHECK-NEXT:        %604 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %603, %604[] : memref<i32>
//CHECK-NEXT:        %605 = arith.constant 200 : i32
//CHECK-NEXT:        %606 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %605, %606[] : memref<i32>
//CHECK-NEXT:        func.call @_QMallocatables_testPmodify_3darray_two(%598, %600, %602, %604, %606) : (memref<10x10x10xi32>, memref<i32>, memref<i32>, memref<i32>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %607 = arith.constant 5 : index
//CHECK-NEXT:        %608 = arith.constant 6 : index
//CHECK-NEXT:        %609 = arith.constant 7 : index
//CHECK-NEXT:        %610 = memref.load %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %611 = memref.load %610[%609, %608, %607] : memref<?x?x?xi32>
//CHECK-NEXT:        %612 = arith.constant 200 : i32
//CHECK-NEXT:        %613 = arith.cmpi eq, %611, %612 : i32
//CHECK-NEXT:        %614 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %613, %614[] : memref<i1>
//CHECK-NEXT:        %615 = arith.constant {{.*}} : index
//CHECK-NEXT:        %616 = arith.index_cast %615 : index to i64
//CHECK-NEXT:        %617 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %618 = "llvm.insertvalue"(%617, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %619 = "llvm.insertvalue"(%618, %616) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %620 = arith.constant 115 : i32
//CHECK-NEXT:        %621 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %620, %621[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%614, %619, %621) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %622 = arith.constant 4 : i32
//CHECK-NEXT:        %623 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %622, %623[] : memref<i32>
//CHECK-NEXT:        %624 = arith.constant 5 : i32
//CHECK-NEXT:        %625 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %624, %625[] : memref<i32>
//CHECK-NEXT:        %626 = arith.constant 6 : i32
//CHECK-NEXT:        %627 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %626, %627[] : memref<i32>
//CHECK-NEXT:        %628 = arith.constant 300 : i32
//CHECK-NEXT:        %629 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %628, %629[] : memref<i32>
//CHECK-NEXT:        func.call @_QMallocatables_testPmodify_3darray_three(%3, %623, %625, %627, %629) : (memref<memref<?x?x?xi32>>, memref<i32>, memref<i32>, memref<i32>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %630 = arith.constant 3 : index
//CHECK-NEXT:        %631 = arith.constant 4 : index
//CHECK-NEXT:        %632 = arith.constant 5 : index
//CHECK-NEXT:        %633 = memref.load %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:        %634 = memref.load %633[%632, %631, %630] : memref<?x?x?xi32>
//CHECK-NEXT:        %635 = arith.constant 300 : i32
//CHECK-NEXT:        %636 = arith.cmpi eq, %634, %635 : i32
//CHECK-NEXT:        %637 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %636, %637[] : memref<i1>
//CHECK-NEXT:        %638 = arith.constant {{.*}} : index
//CHECK-NEXT:        %639 = arith.index_cast %638 : index to i64
//CHECK-NEXT:        %640 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %641 = "llvm.insertvalue"(%640, %71) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %642 = "llvm.insertvalue"(%641, %639) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %643 = arith.constant 117 : i32
//CHECK-NEXT:        %644 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %643, %644[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%637, %642, %644) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %645 = memref.load %1[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.dealloc %645 : memref<?xf32>
//CHECK-NEXT:      %646 = memref.load %2[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.dealloc %646 : memref<?xf32>
//CHECK-NEXT:      %647 = memref.load %3[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:      memref.dealloc %647 : memref<?x?x?xi32>
//CHECK-NEXT:      %648 = memref.load %9[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.dealloc %648 : memref<?xf32>
//CHECK-NEXT:      %649 = memref.load %8[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.dealloc %649 : memref<?xf32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMallocatables_testPmodify_array_one(%0 : memref<?xf32> {fir.bindc_name = "a"}, %1 : memref<i32> {fir.bindc_name = "idx"}, %2 : memref<f32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %3 = memref.load %2[] : memref<f32>
//CHECK-NEXT:      %4 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %5 = arith.extui %4 : i32 to i64
//CHECK-NEXT:      %6 = arith.index_cast %5 : i64 to index
//CHECK-NEXT:      %7 = arith.constant 1 : index
//CHECK-NEXT:      %8 = arith.subi %6, %7 : index
//CHECK-NEXT:      memref.store %3, %0[%8] : memref<?xf32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMallocatables_testPmodify_array_two(%0 : memref<100xf32> {fir.bindc_name = "a"}, %1 : memref<i32> {fir.bindc_name = "idx"}, %2 : memref<f32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %3 = memref.load %2[] : memref<f32>
//CHECK-NEXT:      %4 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %5 = arith.extui %4 : i32 to i64
//CHECK-NEXT:      %6 = arith.index_cast %5 : i64 to index
//CHECK-NEXT:      %7 = arith.constant 1 : index
//CHECK-NEXT:      %8 = arith.subi %6, %7 : index
//CHECK-NEXT:      memref.store %3, %0[%8] : memref<100xf32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMallocatables_testPmodify_array_three(%0 : memref<memref<?xf32>> {fir.bindc_name = "a"}, %1 : memref<i32> {fir.bindc_name = "idx"}, %2 : memref<f32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %3 = memref.load %2[] : memref<f32>
//CHECK-NEXT:      %4 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %5 = arith.extui %4 : i32 to i64
//CHECK-NEXT:      %6 = arith.index_cast %5 : i64 to index
//CHECK-NEXT:      %7 = arith.constant 1 : index
//CHECK-NEXT:      %8 = arith.subi %6, %7 : index
//CHECK-NEXT:      %9 = memref.load %0[] : memref<memref<?xf32>>
//CHECK-NEXT:      memref.store %3, %9[%8] : memref<?xf32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMallocatables_testPmodify_3darray_one(%0 : memref<?x?x?xi32> {fir.bindc_name = "array"}, %1 : memref<i32> {fir.bindc_name = "k"}, %2 : memref<i32> {fir.bindc_name = "j"}, %3 : memref<i32> {fir.bindc_name = "i"}, %4 : memref<i32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %5 = memref.load %4[] : memref<i32>
//CHECK-NEXT:      %6 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %7 = arith.extui %6 : i32 to i64
//CHECK-NEXT:      %8 = arith.index_cast %7 : i64 to index
//CHECK-NEXT:      %9 = arith.constant 1 : index
//CHECK-NEXT:      %10 = arith.subi %8, %9 : index
//CHECK-NEXT:      %11 = memref.load %2[] : memref<i32>
//CHECK-NEXT:      %12 = arith.extui %11 : i32 to i64
//CHECK-NEXT:      %13 = arith.index_cast %12 : i64 to index
//CHECK-NEXT:      %14 = arith.subi %13, %9 : index
//CHECK-NEXT:      %15 = memref.load %3[] : memref<i32>
//CHECK-NEXT:      %16 = arith.extui %15 : i32 to i64
//CHECK-NEXT:      %17 = arith.index_cast %16 : i64 to index
//CHECK-NEXT:      %18 = arith.subi %17, %9 : index
//CHECK-NEXT:      memref.store %5, %0[%18, %14, %10] : memref<?x?x?xi32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMallocatables_testPmodify_3darray_two(%0 : memref<10x10x10xi32> {fir.bindc_name = "array"}, %1 : memref<i32> {fir.bindc_name = "k"}, %2 : memref<i32> {fir.bindc_name = "j"}, %3 : memref<i32> {fir.bindc_name = "i"}, %4 : memref<i32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %5 = memref.load %4[] : memref<i32>
//CHECK-NEXT:      %6 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %7 = arith.extui %6 : i32 to i64
//CHECK-NEXT:      %8 = arith.index_cast %7 : i64 to index
//CHECK-NEXT:      %9 = arith.constant 1 : index
//CHECK-NEXT:      %10 = arith.subi %8, %9 : index
//CHECK-NEXT:      %11 = memref.load %2[] : memref<i32>
//CHECK-NEXT:      %12 = arith.extui %11 : i32 to i64
//CHECK-NEXT:      %13 = arith.index_cast %12 : i64 to index
//CHECK-NEXT:      %14 = arith.subi %13, %9 : index
//CHECK-NEXT:      %15 = memref.load %3[] : memref<i32>
//CHECK-NEXT:      %16 = arith.extui %15 : i32 to i64
//CHECK-NEXT:      %17 = arith.index_cast %16 : i64 to index
//CHECK-NEXT:      %18 = arith.subi %17, %9 : index
//CHECK-NEXT:      memref.store %5, %0[%18, %14, %10] : memref<10x10x10xi32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMallocatables_testPmodify_3darray_three(%0 : memref<memref<?x?x?xi32>> {fir.bindc_name = "array"}, %1 : memref<i32> {fir.bindc_name = "k"}, %2 : memref<i32> {fir.bindc_name = "j"}, %3 : memref<i32> {fir.bindc_name = "i"}, %4 : memref<i32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %5 = memref.load %4[] : memref<i32>
//CHECK-NEXT:      %6 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %7 = arith.extui %6 : i32 to i64
//CHECK-NEXT:      %8 = arith.index_cast %7 : i64 to index
//CHECK-NEXT:      %9 = arith.constant 1 : index
//CHECK-NEXT:      %10 = arith.subi %8, %9 : index
//CHECK-NEXT:      %11 = memref.load %2[] : memref<i32>
//CHECK-NEXT:      %12 = arith.extui %11 : i32 to i64
//CHECK-NEXT:      %13 = arith.index_cast %12 : i64 to index
//CHECK-NEXT:      %14 = arith.subi %13, %9 : index
//CHECK-NEXT:      %15 = memref.load %3[] : memref<i32>
//CHECK-NEXT:      %16 = arith.extui %15 : i32 to i64
//CHECK-NEXT:      %17 = arith.index_cast %16 : i64 to index
//CHECK-NEXT:      %18 = arith.subi %17, %9 : index
//CHECK-NEXT:      %19 = memref.load %0[] : memref<memref<?x?x?xi32>>
//CHECK-NEXT:      memref.store %5, %19[%18, %14, %10] : memref<?x?x?xi32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    "llvm.mlir.global"() <{global_type = !llvm.array<{{[0-9]+}} x i8>, sym_name = "_{{.*}}", linkage = #llvm.linkage<"internal">, addr_space = 0 : i32, constant, value = "{{.*}}", unnamed_addr = 0 : i64}> ({
//CHECK-NEXT:    }) : () -> ()
//CHECK-NEXT:    "memref.global"() <{sym_name = "_QQro.10xr4.0", type = memref<10xf32>, initial_value = dense<[1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00, 7.000000e+00, 8.000000e+00, 9.000000e+00, 1.000000e+01]> : tensor<10xf32>, sym_visibility = "private", constant}> : () -> ()
//CHECK-NEXT:    "memref.global"() <{sym_name = "_QQro.10xr4.1", type = memref<10xf32>, initial_value = dense<[1.100000e+01, 1.200000e+01, 1.300000e+01, 1.400000e+01, 1.500000e+01, 1.600000e+01, 1.700000e+01, 1.800000e+01, 1.900000e+01, 2.000000e+01]> : tensor<10xf32>, sym_visibility = "private", constant}> : () -> ()
//CHECK-NEXT:    func.func private @_QPassert(memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> () 
//CHECK-NEXT:    "llvm.mlir.global"() <{global_type = !llvm.array<{{[0-9]+}} x i8>, sym_name = "_{{.*}}", linkage = #llvm.linkage<"internal">, addr_space = 0 : i32, constant, value = "{{.*}}", unnamed_addr = 0 : i64}> ({
//CHECK-NEXT:    }) : () -> ()
//CHECK-NEXT:  }
//CHECK-EMPTY:  
