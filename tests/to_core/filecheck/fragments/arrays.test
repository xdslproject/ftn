// RUN: xftn %S/../../../../examples/fragments/arrays.F90 -DFRAGMENT_ONLY --stdout -t %S/tmp --cleanup --stages=flang,pre,ftn -v0 | FileCheck %s 
//CHECK:       builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.ident = "flang version 20.1.7 (https://github.com/llvm/llvm-project 6146a88f60492b520a36f8f8f3231e15f3cc6082)", llvm.target_triple = "x86_64-unknown-linux-gnu"} {
//CHECK-NEXT:    "memref.global"() <{sym_name = "_QMarrays_testEglobal_array", type = memref<100xf32>, initial_value, sym_visibility = "private"}> : () -> ()
//CHECK-NEXT:    func.func @_QMarrays_testPcalc() {
//CHECK-NEXT:      %0 = memref.get_global @_QMarrays_testEglobal_array : memref<100xf32>
//CHECK-NEXT:      %1 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<100xf32>
//CHECK-NEXT:      %2 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<100xf32>
//CHECK-NEXT:      %3 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<10x10x10xi32>
//CHECK-NEXT:      %4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %5 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %6 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %7 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %8 = arith.constant true
//CHECK-NEXT:        %9 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %8, %9[] : memref<i1>
//CHECK-NEXT:        %10 = arith.constant {{.*}} : index
//CHECK-NEXT:        %11 = arith.index_cast %10 : index to i64
//CHECK-NEXT:        %12 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %13 = "llvm.insertvalue"(%12, %7) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %14 = "llvm.insertvalue"(%13, %11) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %15 = arith.constant 19 : i32
//CHECK-NEXT:        %16 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %15, %16[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%9, %14, %16) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %17 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %18 = arith.constant true
//CHECK-NEXT:        %19 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %18, %19[] : memref<i1>
//CHECK-NEXT:        %20 = arith.constant {{.*}} : index
//CHECK-NEXT:        %21 = arith.index_cast %20 : index to i64
//CHECK-NEXT:        %22 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %23 = "llvm.insertvalue"(%22, %17) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %24 = "llvm.insertvalue"(%23, %21) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %25 = arith.constant 20 : i32
//CHECK-NEXT:        %26 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %25, %26[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%19, %24, %26) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %27 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %28 = arith.constant true
//CHECK-NEXT:        %29 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %28, %29[] : memref<i1>
//CHECK-NEXT:        %30 = arith.constant {{.*}} : index
//CHECK-NEXT:        %31 = arith.index_cast %30 : index to i64
//CHECK-NEXT:        %32 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %33 = "llvm.insertvalue"(%32, %27) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %34 = "llvm.insertvalue"(%33, %31) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %35 = arith.constant 21 : i32
//CHECK-NEXT:        %36 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %35, %36[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%29, %34, %36) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %37 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %38 = arith.constant true
//CHECK-NEXT:        %39 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %38, %39[] : memref<i1>
//CHECK-NEXT:        %40 = arith.constant {{.*}} : index
//CHECK-NEXT:        %41 = arith.index_cast %40 : index to i64
//CHECK-NEXT:        %42 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %43 = "llvm.insertvalue"(%42, %37) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %44 = "llvm.insertvalue"(%43, %41) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %45 = arith.constant 22 : i32
//CHECK-NEXT:        %46 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %45, %46[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%39, %44, %46) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %47 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %48 = arith.constant true
//CHECK-NEXT:        %49 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %48, %49[] : memref<i1>
//CHECK-NEXT:        %50 = arith.constant {{.*}} : index
//CHECK-NEXT:        %51 = arith.index_cast %50 : index to i64
//CHECK-NEXT:        %52 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %53 = "llvm.insertvalue"(%52, %47) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %54 = "llvm.insertvalue"(%53, %51) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %55 = arith.constant 25 : i32
//CHECK-NEXT:        %56 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %55, %56[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%49, %54, %56) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %57 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %58 = arith.constant true
//CHECK-NEXT:        %59 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %58, %59[] : memref<i1>
//CHECK-NEXT:        %60 = arith.constant {{.*}} : index
//CHECK-NEXT:        %61 = arith.index_cast %60 : index to i64
//CHECK-NEXT:        %62 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %63 = "llvm.insertvalue"(%62, %57) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %64 = "llvm.insertvalue"(%63, %61) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %65 = arith.constant 26 : i32
//CHECK-NEXT:        %66 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %65, %66[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%59, %64, %66) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %67 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %68 = arith.constant true
//CHECK-NEXT:        %69 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %68, %69[] : memref<i1>
//CHECK-NEXT:        %70 = arith.constant {{.*}} : index
//CHECK-NEXT:        %71 = arith.index_cast %70 : index to i64
//CHECK-NEXT:        %72 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %73 = "llvm.insertvalue"(%72, %67) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %74 = "llvm.insertvalue"(%73, %71) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %75 = arith.constant 27 : i32
//CHECK-NEXT:        %76 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %75, %76[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%69, %74, %76) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %77 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %78 = arith.constant true
//CHECK-NEXT:        %79 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %78, %79[] : memref<i1>
//CHECK-NEXT:        %80 = arith.constant {{.*}} : index
//CHECK-NEXT:        %81 = arith.index_cast %80 : index to i64
//CHECK-NEXT:        %82 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %83 = "llvm.insertvalue"(%82, %77) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %84 = "llvm.insertvalue"(%83, %81) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %85 = arith.constant 28 : i32
//CHECK-NEXT:        %86 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %85, %86[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%79, %84, %86) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %87 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %88 = arith.constant true
//CHECK-NEXT:        %89 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %88, %89[] : memref<i1>
//CHECK-NEXT:        %90 = arith.constant {{.*}} : index
//CHECK-NEXT:        %91 = arith.index_cast %90 : index to i64
//CHECK-NEXT:        %92 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %93 = "llvm.insertvalue"(%92, %87) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %94 = "llvm.insertvalue"(%93, %91) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %95 = arith.constant 29 : i32
//CHECK-NEXT:        %96 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %95, %96[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%89, %94, %96) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %97 = arith.constant 1 : i32
//CHECK-NEXT:      %98 = arith.index_cast %97 : i32 to index
//CHECK-NEXT:      %99 = arith.constant 100 : i32
//CHECK-NEXT:      %100 = arith.index_cast %99 : i32 to index
//CHECK-NEXT:      %101 = arith.constant 1 : index
//CHECK-NEXT:      %102 = arith.index_cast %98 : index to i32
//CHECK-NEXT:      %103 = arith.constant 1 : index
//CHECK-NEXT:      %104 = arith.addi %100, %103 : index
//CHECK-NEXT:      %105 = scf.for %106 = %98 to %104 step %101 iter_args(%107 = %102) -> (i32) {
//CHECK-NEXT:        memref.store %107, %4[] : memref<i32>
//CHECK-NEXT:        %108 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %109 = arith.sitofp %108 : i32 to f32
//CHECK-NEXT:        %110 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %111 = arith.extui %110 : i32 to i64
//CHECK-NEXT:        %112 = arith.index_cast %111 : i64 to index
//CHECK-NEXT:        %113 = arith.constant 1 : index
//CHECK-NEXT:        %114 = arith.subi %112, %113 : index
//CHECK-NEXT:        memref.store %109, %1[%114] : memref<100xf32>
//CHECK-NEXT:        %115 = arith.constant 100 : i32
//CHECK-NEXT:        %116 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %117 = arith.subi %115, %116 : i32
//CHECK-NEXT:        %118 = arith.sitofp %117 : i32 to f32
//CHECK-NEXT:        %119 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %120 = arith.extui %119 : i32 to i64
//CHECK-NEXT:        %121 = arith.index_cast %120 : i64 to index
//CHECK-NEXT:        %122 = arith.constant 1 : index
//CHECK-NEXT:        %123 = arith.subi %121, %122 : index
//CHECK-NEXT:        memref.store %118, %2[%123] : memref<100xf32>
//CHECK-NEXT:        %124 = arith.constant 10 : i32
//CHECK-NEXT:        %125 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %126 = arith.muli %124, %125 : i32
//CHECK-NEXT:        %127 = arith.sitofp %126 : i32 to f32
//CHECK-NEXT:        %128 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %129 = arith.extui %128 : i32 to i64
//CHECK-NEXT:        %130 = arith.index_cast %129 : i64 to index
//CHECK-NEXT:        %131 = arith.constant 1 : index
//CHECK-NEXT:        %132 = arith.subi %130, %131 : index
//CHECK-NEXT:        memref.store %127, %0[%132] : memref<100xf32>
//CHECK-NEXT:        %133 = arith.addi %106, %101 : index
//CHECK-NEXT:        %134 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %135 = arith.index_cast %101 : index to i32
//CHECK-NEXT:        %136 = arith.addi %134, %135 : i32
//CHECK-NEXT:        scf.yield %136 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %105, %4[] : memref<i32>
//CHECK-NEXT:      %137 = arith.constant 1 : i32
//CHECK-NEXT:      %138 = arith.index_cast %137 : i32 to index
//CHECK-NEXT:      %139 = arith.constant 100 : i32
//CHECK-NEXT:      %140 = arith.index_cast %139 : i32 to index
//CHECK-NEXT:      %141 = arith.constant 1 : index
//CHECK-NEXT:      %142 = arith.index_cast %138 : index to i32
//CHECK-NEXT:      %143 = arith.constant 1 : index
//CHECK-NEXT:      %144 = arith.addi %140, %143 : index
//CHECK-NEXT:      %145 = scf.for %146 = %138 to %144 step %141 iter_args(%147 = %142) -> (i32) {
//CHECK-NEXT:        memref.store %147, %4[] : memref<i32>
//CHECK-NEXT:        %148 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %149 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %150 = arith.extui %149 : i32 to i64
//CHECK-NEXT:          %151 = arith.index_cast %150 : i64 to index
//CHECK-NEXT:          %152 = arith.constant 1 : index
//CHECK-NEXT:          %153 = arith.subi %151, %152 : index
//CHECK-NEXT:          %154 = memref.load %1[%153] : memref<100xf32>
//CHECK-NEXT:          %155 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %156 = arith.sitofp %155 : i32 to f32
//CHECK-NEXT:          %157 = arith.cmpf oeq, %154, %156 : f32
//CHECK-NEXT:          %158 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %157, %158[] : memref<i1>
//CHECK-NEXT:          %159 = arith.constant {{.*}} : index
//CHECK-NEXT:          %160 = arith.index_cast %159 : index to i64
//CHECK-NEXT:          %161 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %162 = "llvm.insertvalue"(%161, %148) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %163 = "llvm.insertvalue"(%162, %160) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %164 = arith.constant 39 : i32
//CHECK-NEXT:          %165 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %164, %165[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%158, %163, %165) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %166 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %167 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %168 = arith.extui %167 : i32 to i64
//CHECK-NEXT:          %169 = arith.index_cast %168 : i64 to index
//CHECK-NEXT:          %170 = arith.constant 1 : index
//CHECK-NEXT:          %171 = arith.subi %169, %170 : index
//CHECK-NEXT:          %172 = memref.load %2[%171] : memref<100xf32>
//CHECK-NEXT:          %173 = arith.constant 100 : i32
//CHECK-NEXT:          %174 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %175 = arith.subi %173, %174 : i32
//CHECK-NEXT:          %176 = arith.sitofp %175 : i32 to f32
//CHECK-NEXT:          %177 = arith.cmpf oeq, %172, %176 : f32
//CHECK-NEXT:          %178 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %177, %178[] : memref<i1>
//CHECK-NEXT:          %179 = arith.constant {{.*}} : index
//CHECK-NEXT:          %180 = arith.index_cast %179 : index to i64
//CHECK-NEXT:          %181 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %182 = "llvm.insertvalue"(%181, %166) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %183 = "llvm.insertvalue"(%182, %180) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %184 = arith.constant 40 : i32
//CHECK-NEXT:          %185 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %184, %185[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%178, %183, %185) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %186 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %187 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %188 = arith.extui %187 : i32 to i64
//CHECK-NEXT:          %189 = arith.index_cast %188 : i64 to index
//CHECK-NEXT:          %190 = arith.constant 1 : index
//CHECK-NEXT:          %191 = arith.subi %189, %190 : index
//CHECK-NEXT:          %192 = memref.load %0[%191] : memref<100xf32>
//CHECK-NEXT:          %193 = arith.constant 10 : i32
//CHECK-NEXT:          %194 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %195 = arith.muli %193, %194 : i32
//CHECK-NEXT:          %196 = arith.sitofp %195 : i32 to f32
//CHECK-NEXT:          %197 = arith.cmpf oeq, %192, %196 : f32
//CHECK-NEXT:          %198 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %197, %198[] : memref<i1>
//CHECK-NEXT:          %199 = arith.constant {{.*}} : index
//CHECK-NEXT:          %200 = arith.index_cast %199 : index to i64
//CHECK-NEXT:          %201 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %202 = "llvm.insertvalue"(%201, %186) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %203 = "llvm.insertvalue"(%202, %200) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %204 = arith.constant 41 : i32
//CHECK-NEXT:          %205 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %204, %205[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%198, %203, %205) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %206 = arith.addi %146, %141 : index
//CHECK-NEXT:        %207 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %208 = arith.index_cast %141 : index to i32
//CHECK-NEXT:        %209 = arith.addi %207, %208 : i32
//CHECK-NEXT:        scf.yield %209 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %145, %4[] : memref<i32>
//CHECK-NEXT:      %210 = arith.constant 3.450000e+01 : f32
//CHECK-NEXT:      %211 = arith.constant 20 : index
//CHECK-NEXT:      %212 = arith.constant 1 : index
//CHECK-NEXT:      %213 = arith.subi %211, %212 : index
//CHECK-NEXT:      memref.store %210, %1[%213] : memref<100xf32>
//CHECK-NEXT:      %214 = arith.constant 1.652000e+02 : f32
//CHECK-NEXT:      %215 = arith.constant 50 : index
//CHECK-NEXT:      %216 = arith.constant 1 : index
//CHECK-NEXT:      %217 = arith.subi %215, %216 : index
//CHECK-NEXT:      memref.store %214, %2[%217] : memref<100xf32>
//CHECK-NEXT:      %218 = arith.constant 2.310000e+01 : f32
//CHECK-NEXT:      %219 = arith.constant 70 : index
//CHECK-NEXT:      %220 = arith.constant 1 : index
//CHECK-NEXT:      %221 = arith.subi %219, %220 : index
//CHECK-NEXT:      memref.store %218, %0[%221] : memref<100xf32>
//CHECK-NEXT:      %222 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %223 = arith.constant 20 : index
//CHECK-NEXT:        %224 = arith.constant 1 : index
//CHECK-NEXT:        %225 = arith.subi %223, %224 : index
//CHECK-NEXT:        %226 = memref.load %1[%225] : memref<100xf32>
//CHECK-NEXT:        %227 = arith.constant 3.450000e+01 : f32
//CHECK-NEXT:        %228 = arith.cmpf oeq, %226, %227 : f32
//CHECK-NEXT:        %229 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %228, %229[] : memref<i1>
//CHECK-NEXT:        %230 = arith.constant {{.*}} : index
//CHECK-NEXT:        %231 = arith.index_cast %230 : index to i64
//CHECK-NEXT:        %232 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %233 = "llvm.insertvalue"(%232, %222) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %234 = "llvm.insertvalue"(%233, %231) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %235 = arith.constant 48 : i32
//CHECK-NEXT:        %236 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %235, %236[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%229, %234, %236) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %237 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %238 = arith.constant 50 : index
//CHECK-NEXT:        %239 = arith.constant 1 : index
//CHECK-NEXT:        %240 = arith.subi %238, %239 : index
//CHECK-NEXT:        %241 = memref.load %2[%240] : memref<100xf32>
//CHECK-NEXT:        %242 = arith.constant 1.652000e+02 : f32
//CHECK-NEXT:        %243 = arith.cmpf oeq, %241, %242 : f32
//CHECK-NEXT:        %244 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %243, %244[] : memref<i1>
//CHECK-NEXT:        %245 = arith.constant {{.*}} : index
//CHECK-NEXT:        %246 = arith.index_cast %245 : index to i64
//CHECK-NEXT:        %247 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %248 = "llvm.insertvalue"(%247, %237) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %249 = "llvm.insertvalue"(%248, %246) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %250 = arith.constant 49 : i32
//CHECK-NEXT:        %251 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %250, %251[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%244, %249, %251) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %252 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %253 = arith.constant 70 : index
//CHECK-NEXT:        %254 = arith.constant 1 : index
//CHECK-NEXT:        %255 = arith.subi %253, %254 : index
//CHECK-NEXT:        %256 = memref.load %0[%255] : memref<100xf32>
//CHECK-NEXT:        %257 = arith.constant 2.310000e+01 : f32
//CHECK-NEXT:        %258 = arith.cmpf oeq, %256, %257 : f32
//CHECK-NEXT:        %259 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %258, %259[] : memref<i1>
//CHECK-NEXT:        %260 = arith.constant {{.*}} : index
//CHECK-NEXT:        %261 = arith.index_cast %260 : index to i64
//CHECK-NEXT:        %262 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %263 = "llvm.insertvalue"(%262, %252) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %264 = "llvm.insertvalue"(%263, %261) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %265 = arith.constant 50 : i32
//CHECK-NEXT:        %266 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %265, %266[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%259, %264, %266) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %267 = arith.constant 20 : i32
//CHECK-NEXT:        %268 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %267, %268[] : memref<i32>
//CHECK-NEXT:        %269 = arith.constant 2.000000e+01 : f32
//CHECK-NEXT:        %270 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %269, %270[] : memref<f32>
//CHECK-NEXT:        func.call @_QMarrays_testPmodify_array_one(%1, %268, %270) : (memref<100xf32>, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %271 = "memref.cast"(%2) : (memref<100xf32>) -> memref<?xf32>
//CHECK-NEXT:        %272 = arith.constant 50 : i32
//CHECK-NEXT:        %273 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %272, %273[] : memref<i32>
//CHECK-NEXT:        %274 = arith.constant 5.000000e+01 : f32
//CHECK-NEXT:        %275 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %274, %275[] : memref<f32>
//CHECK-NEXT:        func.call @_QMarrays_testPmodify_array_two(%271, %273, %275) : (memref<?xf32>, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %276 = "memref.cast"(%0) : (memref<100xf32>) -> memref<?xf32>
//CHECK-NEXT:        %277 = arith.constant 70 : i32
//CHECK-NEXT:        %278 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %277, %278[] : memref<i32>
//CHECK-NEXT:        %279 = arith.constant 7.000000e+02 : f32
//CHECK-NEXT:        %280 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %279, %280[] : memref<f32>
//CHECK-NEXT:        func.call @_QMarrays_testPmodify_array_two(%276, %278, %280) : (memref<?xf32>, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %281 = arith.constant 1 : i32
//CHECK-NEXT:      %282 = arith.index_cast %281 : i32 to index
//CHECK-NEXT:      %283 = arith.constant 100 : i32
//CHECK-NEXT:      %284 = arith.index_cast %283 : i32 to index
//CHECK-NEXT:      %285 = arith.constant 1 : index
//CHECK-NEXT:      %286 = arith.index_cast %282 : index to i32
//CHECK-NEXT:      %287 = arith.constant 1 : index
//CHECK-NEXT:      %288 = arith.addi %284, %287 : index
//CHECK-NEXT:      %289 = scf.for %290 = %282 to %288 step %285 iter_args(%291 = %286) -> (i32) {
//CHECK-NEXT:        memref.store %291, %4[] : memref<i32>
//CHECK-NEXT:        %292 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %293 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %294 = arith.extui %293 : i32 to i64
//CHECK-NEXT:          %295 = arith.index_cast %294 : i64 to index
//CHECK-NEXT:          %296 = arith.constant 1 : index
//CHECK-NEXT:          %297 = arith.subi %295, %296 : index
//CHECK-NEXT:          %298 = memref.load %1[%297] : memref<100xf32>
//CHECK-NEXT:          %299 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %300 = arith.sitofp %299 : i32 to f32
//CHECK-NEXT:          %301 = arith.cmpf oeq, %298, %300 : f32
//CHECK-NEXT:          %302 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %301, %302[] : memref<i1>
//CHECK-NEXT:          %303 = arith.constant {{.*}} : index
//CHECK-NEXT:          %304 = arith.index_cast %303 : index to i64
//CHECK-NEXT:          %305 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %306 = "llvm.insertvalue"(%305, %292) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %307 = "llvm.insertvalue"(%306, %304) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %308 = arith.constant 58 : i32
//CHECK-NEXT:          %309 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %308, %309[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%302, %307, %309) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %310 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %311 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %312 = arith.extui %311 : i32 to i64
//CHECK-NEXT:          %313 = arith.index_cast %312 : i64 to index
//CHECK-NEXT:          %314 = arith.constant 1 : index
//CHECK-NEXT:          %315 = arith.subi %313, %314 : index
//CHECK-NEXT:          %316 = memref.load %2[%315] : memref<100xf32>
//CHECK-NEXT:          %317 = arith.constant 100 : i32
//CHECK-NEXT:          %318 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %319 = arith.subi %317, %318 : i32
//CHECK-NEXT:          %320 = arith.sitofp %319 : i32 to f32
//CHECK-NEXT:          %321 = arith.cmpf oeq, %316, %320 : f32
//CHECK-NEXT:          %322 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %321, %322[] : memref<i1>
//CHECK-NEXT:          %323 = arith.constant {{.*}} : index
//CHECK-NEXT:          %324 = arith.index_cast %323 : index to i64
//CHECK-NEXT:          %325 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %326 = "llvm.insertvalue"(%325, %310) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %327 = "llvm.insertvalue"(%326, %324) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %328 = arith.constant 59 : i32
//CHECK-NEXT:          %329 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %328, %329[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%322, %327, %329) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %330 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %331 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %332 = arith.extui %331 : i32 to i64
//CHECK-NEXT:          %333 = arith.index_cast %332 : i64 to index
//CHECK-NEXT:          %334 = arith.constant 1 : index
//CHECK-NEXT:          %335 = arith.subi %333, %334 : index
//CHECK-NEXT:          %336 = memref.load %0[%335] : memref<100xf32>
//CHECK-NEXT:          %337 = arith.constant 10 : i32
//CHECK-NEXT:          %338 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %339 = arith.muli %337, %338 : i32
//CHECK-NEXT:          %340 = arith.sitofp %339 : i32 to f32
//CHECK-NEXT:          %341 = arith.cmpf oeq, %336, %340 : f32
//CHECK-NEXT:          %342 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %341, %342[] : memref<i1>
//CHECK-NEXT:          %343 = arith.constant {{.*}} : index
//CHECK-NEXT:          %344 = arith.index_cast %343 : index to i64
//CHECK-NEXT:          %345 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %346 = "llvm.insertvalue"(%345, %330) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %347 = "llvm.insertvalue"(%346, %344) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %348 = arith.constant 60 : i32
//CHECK-NEXT:          %349 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %348, %349[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%342, %347, %349) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %350 = arith.addi %290, %285 : index
//CHECK-NEXT:        %351 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %352 = arith.index_cast %285 : index to i32
//CHECK-NEXT:        %353 = arith.addi %351, %352 : i32
//CHECK-NEXT:        scf.yield %353 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %289, %4[] : memref<i32>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %354 = arith.constant 60 : i32
//CHECK-NEXT:        %355 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %354, %355[] : memref<i32>
//CHECK-NEXT:        %356 = arith.constant 1.234000e+02 : f32
//CHECK-NEXT:        %357 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %356, %357[] : memref<f32>
//CHECK-NEXT:        func.call @_QMarrays_testPmodify_array_one(%0, %355, %357) : (memref<100xf32>, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %358 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %359 = arith.constant 60 : index
//CHECK-NEXT:        %360 = arith.constant 1 : index
//CHECK-NEXT:        %361 = arith.subi %359, %360 : index
//CHECK-NEXT:        %362 = memref.load %0[%361] : memref<100xf32>
//CHECK-NEXT:        %363 = arith.constant 1.234000e+02 : f32
//CHECK-NEXT:        %364 = arith.cmpf oeq, %362, %363 : f32
//CHECK-NEXT:        %365 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %364, %365[] : memref<i1>
//CHECK-NEXT:        %366 = arith.constant {{.*}} : index
//CHECK-NEXT:        %367 = arith.index_cast %366 : index to i64
//CHECK-NEXT:        %368 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %369 = "llvm.insertvalue"(%368, %358) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %370 = "llvm.insertvalue"(%369, %367) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %371 = arith.constant 64 : i32
//CHECK-NEXT:        %372 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %371, %372[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%365, %370, %372) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %373 = arith.constant 1 : i32
//CHECK-NEXT:      %374 = arith.index_cast %373 : i32 to index
//CHECK-NEXT:      %375 = arith.constant 10 : i32
//CHECK-NEXT:      %376 = arith.index_cast %375 : i32 to index
//CHECK-NEXT:      %377 = arith.constant 1 : index
//CHECK-NEXT:      %378 = arith.index_cast %374 : index to i32
//CHECK-NEXT:      %379 = arith.constant 1 : index
//CHECK-NEXT:      %380 = arith.addi %376, %379 : index
//CHECK-NEXT:      %381 = scf.for %382 = %374 to %380 step %377 iter_args(%383 = %378) -> (i32) {
//CHECK-NEXT:        memref.store %383, %4[] : memref<i32>
//CHECK-NEXT:        %384 = arith.constant 1 : i32
//CHECK-NEXT:        %385 = arith.index_cast %384 : i32 to index
//CHECK-NEXT:        %386 = arith.constant 10 : i32
//CHECK-NEXT:        %387 = arith.index_cast %386 : i32 to index
//CHECK-NEXT:        %388 = arith.constant 1 : index
//CHECK-NEXT:        %389 = arith.index_cast %385 : index to i32
//CHECK-NEXT:        %390 = arith.constant 1 : index
//CHECK-NEXT:        %391 = arith.addi %387, %390 : index
//CHECK-NEXT:        %392 = scf.for %393 = %385 to %391 step %388 iter_args(%394 = %389) -> (i32) {
//CHECK-NEXT:          memref.store %394, %5[] : memref<i32>
//CHECK-NEXT:          %395 = arith.constant 1 : i32
//CHECK-NEXT:          %396 = arith.index_cast %395 : i32 to index
//CHECK-NEXT:          %397 = arith.constant 10 : i32
//CHECK-NEXT:          %398 = arith.index_cast %397 : i32 to index
//CHECK-NEXT:          %399 = arith.constant 1 : index
//CHECK-NEXT:          %400 = arith.index_cast %396 : index to i32
//CHECK-NEXT:          %401 = arith.constant 1 : index
//CHECK-NEXT:          %402 = arith.addi %398, %401 : index
//CHECK-NEXT:          %403 = scf.for %404 = %396 to %402 step %399 iter_args(%405 = %400) -> (i32) {
//CHECK-NEXT:            memref.store %405, %6[] : memref<i32>
//CHECK-NEXT:            %406 = memref.load %6[] : memref<i32>
//CHECK-NEXT:            %407 = arith.constant 10 : i32
//CHECK-NEXT:            %408 = memref.load %5[] : memref<i32>
//CHECK-NEXT:            %409 = arith.muli %407, %408 : i32
//CHECK-NEXT:            %410 = arith.addi %406, %409 : i32
//CHECK-NEXT:            %411 = arith.constant 100 : i32
//CHECK-NEXT:            %412 = memref.load %4[] : memref<i32>
//CHECK-NEXT:            %413 = arith.muli %411, %412 : i32
//CHECK-NEXT:            %414 = arith.addi %410, %413 : i32
//CHECK-NEXT:            %415 = memref.load %6[] : memref<i32>
//CHECK-NEXT:            %416 = arith.extui %415 : i32 to i64
//CHECK-NEXT:            %417 = arith.index_cast %416 : i64 to index
//CHECK-NEXT:            %418 = arith.constant 1 : index
//CHECK-NEXT:            %419 = arith.subi %417, %418 : index
//CHECK-NEXT:            %420 = memref.load %5[] : memref<i32>
//CHECK-NEXT:            %421 = arith.extui %420 : i32 to i64
//CHECK-NEXT:            %422 = arith.index_cast %421 : i64 to index
//CHECK-NEXT:            %423 = arith.constant 1 : index
//CHECK-NEXT:            %424 = arith.subi %422, %423 : index
//CHECK-NEXT:            %425 = memref.load %4[] : memref<i32>
//CHECK-NEXT:            %426 = arith.extui %425 : i32 to i64
//CHECK-NEXT:            %427 = arith.index_cast %426 : i64 to index
//CHECK-NEXT:            %428 = arith.constant 1 : index
//CHECK-NEXT:            %429 = arith.subi %427, %428 : index
//CHECK-NEXT:            memref.store %414, %3[%429, %424, %419] : memref<10x10x10xi32>
//CHECK-NEXT:            %430 = arith.addi %404, %399 : index
//CHECK-NEXT:            %431 = memref.load %6[] : memref<i32>
//CHECK-NEXT:            %432 = arith.index_cast %399 : index to i32
//CHECK-NEXT:            %433 = arith.addi %431, %432 : i32
//CHECK-NEXT:            scf.yield %433 : i32
//CHECK-NEXT:          }
//CHECK-NEXT:          memref.store %403, %6[] : memref<i32>
//CHECK-NEXT:          %434 = arith.addi %393, %388 : index
//CHECK-NEXT:          %435 = memref.load %5[] : memref<i32>
//CHECK-NEXT:          %436 = arith.index_cast %388 : index to i32
//CHECK-NEXT:          %437 = arith.addi %435, %436 : i32
//CHECK-NEXT:          scf.yield %437 : i32
//CHECK-NEXT:        }
//CHECK-NEXT:        memref.store %392, %5[] : memref<i32>
//CHECK-NEXT:        %438 = arith.addi %382, %377 : index
//CHECK-NEXT:        %439 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %440 = arith.index_cast %377 : index to i32
//CHECK-NEXT:        %441 = arith.addi %439, %440 : i32
//CHECK-NEXT:        scf.yield %441 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %381, %4[] : memref<i32>
//CHECK-NEXT:      %442 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %443 = arith.constant 3 : index
//CHECK-NEXT:        %444 = arith.constant 1 : index
//CHECK-NEXT:        %445 = arith.subi %443, %444 : index
//CHECK-NEXT:        %446 = arith.constant 4 : index
//CHECK-NEXT:        %447 = arith.constant 1 : index
//CHECK-NEXT:        %448 = arith.subi %446, %447 : index
//CHECK-NEXT:        %449 = arith.constant 5 : index
//CHECK-NEXT:        %450 = arith.constant 1 : index
//CHECK-NEXT:        %451 = arith.subi %449, %450 : index
//CHECK-NEXT:        %452 = memref.load %3[%451, %448, %445] : memref<10x10x10xi32>
//CHECK-NEXT:        %453 = arith.constant 543 : i32
//CHECK-NEXT:        %454 = arith.cmpi eq, %452, %453 : i32
//CHECK-NEXT:        %455 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %454, %455[] : memref<i1>
//CHECK-NEXT:        %456 = arith.constant {{.*}} : index
//CHECK-NEXT:        %457 = arith.index_cast %456 : index to i64
//CHECK-NEXT:        %458 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %459 = "llvm.insertvalue"(%458, %442) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %460 = "llvm.insertvalue"(%459, %457) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %461 = arith.constant 74 : i32
//CHECK-NEXT:        %462 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %461, %462[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%455, %460, %462) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %463 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %464 = arith.constant 8 : index
//CHECK-NEXT:        %465 = arith.constant 1 : index
//CHECK-NEXT:        %466 = arith.subi %464, %465 : index
//CHECK-NEXT:        %467 = arith.constant 9 : index
//CHECK-NEXT:        %468 = arith.constant 1 : index
//CHECK-NEXT:        %469 = arith.subi %467, %468 : index
//CHECK-NEXT:        %470 = arith.constant 1 : index
//CHECK-NEXT:        %471 = arith.constant 1 : index
//CHECK-NEXT:        %472 = arith.subi %470, %471 : index
//CHECK-NEXT:        %473 = memref.load %3[%472, %469, %466] : memref<10x10x10xi32>
//CHECK-NEXT:        %474 = arith.constant 198 : i32
//CHECK-NEXT:        %475 = arith.cmpi eq, %473, %474 : i32
//CHECK-NEXT:        %476 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %475, %476[] : memref<i1>
//CHECK-NEXT:        %477 = arith.constant {{.*}} : index
//CHECK-NEXT:        %478 = arith.index_cast %477 : index to i64
//CHECK-NEXT:        %479 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %480 = "llvm.insertvalue"(%479, %463) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %481 = "llvm.insertvalue"(%480, %478) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %482 = arith.constant 75 : i32
//CHECK-NEXT:        %483 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %482, %483[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%476, %481, %483) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMarrays_testPmodify_array_one(%0 : memref<100xf32> {fir.bindc_name = "a"}, %1 : memref<i32> {fir.bindc_name = "idx"}, %2 : memref<f32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %3 = memref.load %2[] : memref<f32>
//CHECK-NEXT:      %4 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %5 = arith.extui %4 : i32 to i64
//CHECK-NEXT:      %6 = arith.index_cast %5 : i64 to index
//CHECK-NEXT:      %7 = arith.constant 1 : index
//CHECK-NEXT:      %8 = arith.subi %6, %7 : index
//CHECK-NEXT:      memref.store %3, %0[%8] : memref<100xf32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMarrays_testPmodify_array_two(%0 : memref<?xf32> {fir.bindc_name = "a"}, %1 : memref<i32> {fir.bindc_name = "idx"}, %2 : memref<f32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %3 = arith.constant 1 : index
//CHECK-NEXT:      %4 = arith.constant 0 : index
//CHECK-NEXT:      %5 = "memref.dim"(%0, %4) : (memref<?xf32>, index) -> index
//CHECK-NEXT:      %6 = arith.addi %5, %3 : index
//CHECK-NEXT:      %7 = memref.load %2[] : memref<f32>
//CHECK-NEXT:      %8 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %9 = arith.extui %8 : i32 to i64
//CHECK-NEXT:      %10 = arith.index_cast %9 : i64 to index
//CHECK-NEXT:      %11 = arith.constant 1 : index
//CHECK-NEXT:      %12 = arith.subi %10, %11 : index
//CHECK-NEXT:      memref.store %7, %0[%12] : memref<?xf32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func private @_QPassert(memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> () 
//CHECK-NEXT:    "llvm.mlir.global"() <{global_type = !llvm.array<{{[0-9]+}} x i8>, sym_name = "_{{.*}}", linkage = #llvm.linkage<"internal">, addr_space = 0 : i32, constant, value = "{{.*}}", unnamed_addr = 0 : i64}> ({
//CHECK-NEXT:    }) : () -> ()
//CHECK-NEXT:  }
//CHECK-EMPTY:  
