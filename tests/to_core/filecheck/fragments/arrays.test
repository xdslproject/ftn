// RUN: xftn %S/../../../../examples/fragments/arrays.F90 -DFRAGMENT_ONLY --stdout -t %S/tmp --cleanup --stages=flang,pre,ftn -v0 | FileCheck %s 
//CHECK:       builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.ident = "flang version 20.1.7 (https://github.com/llvm/llvm-project 6146a88f60492b520a36f8f8f3231e15f3cc6082)", llvm.target_triple = "x86_64-unknown-linux-gnu"} {
//CHECK-NEXT:    "memref.global"() <{sym_name = "_QMarrays_testEglobal_array", type = memref<100xf32>, initial_value, sym_visibility = "private"}> : () -> ()
//CHECK-NEXT:    func.func @_QMarrays_testPcalc() {
//CHECK-NEXT:      %0 = memref.get_global @_QMarrays_testEglobal_array : memref<100xf32>
//CHECK-NEXT:      %1 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<100xf32>
//CHECK-NEXT:      %2 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<100xf32>
//CHECK-NEXT:      %3 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<15x5x10xi32>
//CHECK-NEXT:      %4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %5 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %6 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %7 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<10xf32>
//CHECK-NEXT:      %8 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<10xf32>
//CHECK-NEXT:      %9 = memref.get_global @_QQro.10xr4.0 : memref<10xf32>
//CHECK-NEXT:      "memref.copy"(%9, %8) : (memref<10xf32>, memref<10xf32>) -> ()
//CHECK-NEXT:      %10 = memref.get_global @_QQro.10xr4.1 : memref<10xf32>
//CHECK-NEXT:      "memref.copy"(%10, %7) : (memref<10xf32>, memref<10xf32>) -> ()
//CHECK-NEXT:      %11 = arith.constant 1 : i32
//CHECK-NEXT:      %12 = arith.index_cast %11 : i32 to index
//CHECK-NEXT:      %13 = arith.constant 10 : i32
//CHECK-NEXT:      %14 = arith.index_cast %13 : i32 to index
//CHECK-NEXT:      %15 = arith.constant 1 : index
//CHECK-NEXT:      %16 = arith.index_cast %12 : index to i32
//CHECK-NEXT:      %17 = arith.addi %14, %15 : index
//CHECK-NEXT:      %18 = scf.for %19 = %12 to %17 step %15 iter_args(%20 = %16) -> (i32) {
//CHECK-NEXT:        memref.store %20, %4[] : memref<i32>
//CHECK-NEXT:        %21 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %22 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %23 = arith.extui %22 : i32 to i64
//CHECK-NEXT:          %24 = arith.index_cast %23 : i64 to index
//CHECK-NEXT:          %25 = arith.subi %24, %15 : index
//CHECK-NEXT:          %26 = memref.load %8[%25] : memref<10xf32>
//CHECK-NEXT:          %27 = arith.sitofp %22 : i32 to f32
//CHECK-NEXT:          %28 = arith.cmpf oeq, %26, %27 : f32
//CHECK-NEXT:          %29 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %28, %29[] : memref<i1>
//CHECK-NEXT:          %30 = arith.constant {{.*}} : index
//CHECK-NEXT:          %31 = arith.index_cast %30 : index to i64
//CHECK-NEXT:          %32 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %33 = "llvm.insertvalue"(%32, %21) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %34 = "llvm.insertvalue"(%33, %31) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %35 = arith.constant 23 : i32
//CHECK-NEXT:          %36 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %35, %36[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%29, %34, %36) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %37 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %38 = arith.extui %37 : i32 to i64
//CHECK-NEXT:          %39 = arith.index_cast %38 : i64 to index
//CHECK-NEXT:          %40 = arith.subi %39, %15 : index
//CHECK-NEXT:          %41 = memref.load %7[%40] : memref<10xf32>
//CHECK-NEXT:          %42 = arith.addi %37, %13 : i32
//CHECK-NEXT:          %43 = arith.sitofp %42 : i32 to f32
//CHECK-NEXT:          %44 = arith.cmpf oeq, %41, %43 : f32
//CHECK-NEXT:          %45 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %44, %45[] : memref<i1>
//CHECK-NEXT:          %46 = arith.constant {{.*}} : index
//CHECK-NEXT:          %47 = arith.index_cast %46 : index to i64
//CHECK-NEXT:          %48 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %49 = "llvm.insertvalue"(%48, %21) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %50 = "llvm.insertvalue"(%49, %47) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %51 = arith.constant 24 : i32
//CHECK-NEXT:          %52 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %51, %52[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%45, %50, %52) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %53 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %54 = arith.index_cast %15 : index to i32
//CHECK-NEXT:        %55 = arith.addi %53, %54 : i32
//CHECK-NEXT:        scf.yield %55 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %18, %4[] : memref<i32>
//CHECK-NEXT:      %56 = "llvm.mlir.addressof"() <{global_name = @{{.*}}}> : () -> !llvm.ptr
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %57 = arith.constant true
//CHECK-NEXT:        %58 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %57, %58[] : memref<i1>
//CHECK-NEXT:        %59 = arith.constant {{.*}} : index
//CHECK-NEXT:        %60 = arith.index_cast %59 : index to i64
//CHECK-NEXT:        %61 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %62 = "llvm.insertvalue"(%61, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %63 = "llvm.insertvalue"(%62, %60) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %64 = arith.constant 28 : i32
//CHECK-NEXT:        %65 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %64, %65[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%58, %63, %65) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %66 = arith.constant true
//CHECK-NEXT:        %67 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %66, %67[] : memref<i1>
//CHECK-NEXT:        %68 = arith.constant {{.*}} : index
//CHECK-NEXT:        %69 = arith.index_cast %68 : index to i64
//CHECK-NEXT:        %70 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %71 = "llvm.insertvalue"(%70, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %72 = "llvm.insertvalue"(%71, %69) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %73 = arith.constant 29 : i32
//CHECK-NEXT:        %74 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %73, %74[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%67, %72, %74) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %75 = arith.constant true
//CHECK-NEXT:        %76 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %75, %76[] : memref<i1>
//CHECK-NEXT:        %77 = arith.constant {{.*}} : index
//CHECK-NEXT:        %78 = arith.index_cast %77 : index to i64
//CHECK-NEXT:        %79 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %80 = "llvm.insertvalue"(%79, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %81 = "llvm.insertvalue"(%80, %78) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %82 = arith.constant 30 : i32
//CHECK-NEXT:        %83 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %82, %83[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%76, %81, %83) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %84 = arith.constant true
//CHECK-NEXT:        %85 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %84, %85[] : memref<i1>
//CHECK-NEXT:        %86 = arith.constant {{.*}} : index
//CHECK-NEXT:        %87 = arith.index_cast %86 : index to i64
//CHECK-NEXT:        %88 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %89 = "llvm.insertvalue"(%88, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %90 = "llvm.insertvalue"(%89, %87) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %91 = arith.constant 31 : i32
//CHECK-NEXT:        %92 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %91, %92[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%85, %90, %92) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %93 = arith.constant true
//CHECK-NEXT:        %94 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %93, %94[] : memref<i1>
//CHECK-NEXT:        %95 = arith.constant {{.*}} : index
//CHECK-NEXT:        %96 = arith.index_cast %95 : index to i64
//CHECK-NEXT:        %97 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %98 = "llvm.insertvalue"(%97, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %99 = "llvm.insertvalue"(%98, %96) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %100 = arith.constant 34 : i32
//CHECK-NEXT:        %101 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %100, %101[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%94, %99, %101) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %102 = arith.constant true
//CHECK-NEXT:        %103 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %102, %103[] : memref<i1>
//CHECK-NEXT:        %104 = arith.constant {{.*}} : index
//CHECK-NEXT:        %105 = arith.index_cast %104 : index to i64
//CHECK-NEXT:        %106 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %107 = "llvm.insertvalue"(%106, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %108 = "llvm.insertvalue"(%107, %105) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %109 = arith.constant 35 : i32
//CHECK-NEXT:        %110 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %109, %110[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%103, %108, %110) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %111 = arith.constant true
//CHECK-NEXT:        %112 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %111, %112[] : memref<i1>
//CHECK-NEXT:        %113 = arith.constant {{.*}} : index
//CHECK-NEXT:        %114 = arith.index_cast %113 : index to i64
//CHECK-NEXT:        %115 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %116 = "llvm.insertvalue"(%115, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %117 = "llvm.insertvalue"(%116, %114) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %118 = arith.constant 36 : i32
//CHECK-NEXT:        %119 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %118, %119[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%112, %117, %119) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %120 = arith.constant true
//CHECK-NEXT:        %121 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %120, %121[] : memref<i1>
//CHECK-NEXT:        %122 = arith.constant {{.*}} : index
//CHECK-NEXT:        %123 = arith.index_cast %122 : index to i64
//CHECK-NEXT:        %124 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %125 = "llvm.insertvalue"(%124, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %126 = "llvm.insertvalue"(%125, %123) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %127 = arith.constant 37 : i32
//CHECK-NEXT:        %128 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %127, %128[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%121, %126, %128) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %129 = arith.constant true
//CHECK-NEXT:        %130 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %129, %130[] : memref<i1>
//CHECK-NEXT:        %131 = arith.constant {{.*}} : index
//CHECK-NEXT:        %132 = arith.index_cast %131 : index to i64
//CHECK-NEXT:        %133 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %134 = "llvm.insertvalue"(%133, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %135 = "llvm.insertvalue"(%134, %132) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %136 = arith.constant 38 : i32
//CHECK-NEXT:        %137 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %136, %137[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%130, %135, %137) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %138 = arith.constant true
//CHECK-NEXT:        %139 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %138, %139[] : memref<i1>
//CHECK-NEXT:        %140 = arith.constant {{.*}} : index
//CHECK-NEXT:        %141 = arith.index_cast %140 : index to i64
//CHECK-NEXT:        %142 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %143 = "llvm.insertvalue"(%142, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %144 = "llvm.insertvalue"(%143, %141) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %145 = arith.constant 39 : i32
//CHECK-NEXT:        %146 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %145, %146[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%139, %144, %146) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %147 = arith.constant true
//CHECK-NEXT:        %148 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %147, %148[] : memref<i1>
//CHECK-NEXT:        %149 = arith.constant {{.*}} : index
//CHECK-NEXT:        %150 = arith.index_cast %149 : index to i64
//CHECK-NEXT:        %151 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %152 = "llvm.insertvalue"(%151, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %153 = "llvm.insertvalue"(%152, %150) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %154 = arith.constant 40 : i32
//CHECK-NEXT:        %155 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %154, %155[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%148, %153, %155) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %156 = arith.constant 100 : i32
//CHECK-NEXT:      %157 = arith.index_cast %156 : i32 to index
//CHECK-NEXT:      %158 = arith.addi %157, %15 : index
//CHECK-NEXT:      %159 = scf.for %160 = %12 to %158 step %15 iter_args(%161 = %16) -> (i32) {
//CHECK-NEXT:        memref.store %161, %4[] : memref<i32>
//CHECK-NEXT:        %162 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %163 = arith.sitofp %162 : i32 to f32
//CHECK-NEXT:        %164 = arith.extui %162 : i32 to i64
//CHECK-NEXT:        %165 = arith.index_cast %164 : i64 to index
//CHECK-NEXT:        %166 = arith.subi %165, %15 : index
//CHECK-NEXT:        memref.store %163, %1[%166] : memref<100xf32>
//CHECK-NEXT:        %167 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %168 = arith.subi %156, %167 : i32
//CHECK-NEXT:        %169 = arith.sitofp %168 : i32 to f32
//CHECK-NEXT:        %170 = arith.extui %167 : i32 to i64
//CHECK-NEXT:        %171 = arith.index_cast %170 : i64 to index
//CHECK-NEXT:        %172 = arith.subi %171, %15 : index
//CHECK-NEXT:        memref.store %169, %2[%172] : memref<100xf32>
//CHECK-NEXT:        %173 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %174 = arith.muli %173, %13 : i32
//CHECK-NEXT:        %175 = arith.sitofp %174 : i32 to f32
//CHECK-NEXT:        %176 = arith.extui %173 : i32 to i64
//CHECK-NEXT:        %177 = arith.index_cast %176 : i64 to index
//CHECK-NEXT:        %178 = arith.subi %177, %15 : index
//CHECK-NEXT:        memref.store %175, %0[%178] : memref<100xf32>
//CHECK-NEXT:        %179 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %180 = arith.index_cast %15 : index to i32
//CHECK-NEXT:        %181 = arith.addi %179, %180 : i32
//CHECK-NEXT:        scf.yield %181 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %159, %4[] : memref<i32>
//CHECK-NEXT:      %182 = scf.for %183 = %12 to %158 step %15 iter_args(%184 = %16) -> (i32) {
//CHECK-NEXT:        memref.store %184, %4[] : memref<i32>
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %185 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %186 = arith.extui %185 : i32 to i64
//CHECK-NEXT:          %187 = arith.index_cast %186 : i64 to index
//CHECK-NEXT:          %188 = arith.subi %187, %15 : index
//CHECK-NEXT:          %189 = memref.load %1[%188] : memref<100xf32>
//CHECK-NEXT:          %190 = arith.sitofp %185 : i32 to f32
//CHECK-NEXT:          %191 = arith.cmpf oeq, %189, %190 : f32
//CHECK-NEXT:          %192 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %191, %192[] : memref<i1>
//CHECK-NEXT:          %193 = arith.constant {{.*}} : index
//CHECK-NEXT:          %194 = arith.index_cast %193 : index to i64
//CHECK-NEXT:          %195 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %196 = "llvm.insertvalue"(%195, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %197 = "llvm.insertvalue"(%196, %194) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %198 = arith.constant 50 : i32
//CHECK-NEXT:          %199 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %198, %199[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%192, %197, %199) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %200 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %201 = arith.extui %200 : i32 to i64
//CHECK-NEXT:          %202 = arith.index_cast %201 : i64 to index
//CHECK-NEXT:          %203 = arith.subi %202, %15 : index
//CHECK-NEXT:          %204 = memref.load %2[%203] : memref<100xf32>
//CHECK-NEXT:          %205 = arith.subi %156, %200 : i32
//CHECK-NEXT:          %206 = arith.sitofp %205 : i32 to f32
//CHECK-NEXT:          %207 = arith.cmpf oeq, %204, %206 : f32
//CHECK-NEXT:          %208 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %207, %208[] : memref<i1>
//CHECK-NEXT:          %209 = arith.constant {{.*}} : index
//CHECK-NEXT:          %210 = arith.index_cast %209 : index to i64
//CHECK-NEXT:          %211 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %212 = "llvm.insertvalue"(%211, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %213 = "llvm.insertvalue"(%212, %210) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %214 = arith.constant 51 : i32
//CHECK-NEXT:          %215 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %214, %215[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%208, %213, %215) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %216 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %217 = arith.extui %216 : i32 to i64
//CHECK-NEXT:          %218 = arith.index_cast %217 : i64 to index
//CHECK-NEXT:          %219 = arith.subi %218, %15 : index
//CHECK-NEXT:          %220 = memref.load %0[%219] : memref<100xf32>
//CHECK-NEXT:          %221 = arith.muli %216, %13 : i32
//CHECK-NEXT:          %222 = arith.sitofp %221 : i32 to f32
//CHECK-NEXT:          %223 = arith.cmpf oeq, %220, %222 : f32
//CHECK-NEXT:          %224 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %223, %224[] : memref<i1>
//CHECK-NEXT:          %225 = arith.constant {{.*}} : index
//CHECK-NEXT:          %226 = arith.index_cast %225 : index to i64
//CHECK-NEXT:          %227 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %228 = "llvm.insertvalue"(%227, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %229 = "llvm.insertvalue"(%228, %226) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %230 = arith.constant 52 : i32
//CHECK-NEXT:          %231 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %230, %231[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%224, %229, %231) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %232 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %233 = arith.index_cast %15 : index to i32
//CHECK-NEXT:        %234 = arith.addi %232, %233 : i32
//CHECK-NEXT:        scf.yield %234 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %182, %4[] : memref<i32>
//CHECK-NEXT:      %235 = arith.constant 3.450000e+01 : f32
//CHECK-NEXT:      %236 = arith.constant 19 : index
//CHECK-NEXT:      memref.store %235, %1[%236] : memref<100xf32>
//CHECK-NEXT:      %237 = arith.constant 1.652000e+02 : f32
//CHECK-NEXT:      %238 = arith.constant 49 : index
//CHECK-NEXT:      memref.store %237, %2[%238] : memref<100xf32>
//CHECK-NEXT:      %239 = arith.constant 2.310000e+01 : f32
//CHECK-NEXT:      %240 = arith.constant 69 : index
//CHECK-NEXT:      memref.store %239, %0[%240] : memref<100xf32>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %241 = memref.load %1[%236] : memref<100xf32>
//CHECK-NEXT:        %242 = arith.cmpf oeq, %241, %235 : f32
//CHECK-NEXT:        %243 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %242, %243[] : memref<i1>
//CHECK-NEXT:        %244 = arith.constant {{.*}} : index
//CHECK-NEXT:        %245 = arith.index_cast %244 : index to i64
//CHECK-NEXT:        %246 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %247 = "llvm.insertvalue"(%246, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %248 = "llvm.insertvalue"(%247, %245) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %249 = arith.constant 59 : i32
//CHECK-NEXT:        %250 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %249, %250[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%243, %248, %250) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %251 = memref.load %2[%238] : memref<100xf32>
//CHECK-NEXT:        %252 = arith.cmpf oeq, %251, %237 : f32
//CHECK-NEXT:        %253 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %252, %253[] : memref<i1>
//CHECK-NEXT:        %254 = arith.constant {{.*}} : index
//CHECK-NEXT:        %255 = arith.index_cast %254 : index to i64
//CHECK-NEXT:        %256 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %257 = "llvm.insertvalue"(%256, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %258 = "llvm.insertvalue"(%257, %255) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %259 = arith.constant 60 : i32
//CHECK-NEXT:        %260 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %259, %260[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%253, %258, %260) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %261 = memref.load %0[%240] : memref<100xf32>
//CHECK-NEXT:        %262 = arith.cmpf oeq, %261, %239 : f32
//CHECK-NEXT:        %263 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %262, %263[] : memref<i1>
//CHECK-NEXT:        %264 = arith.constant {{.*}} : index
//CHECK-NEXT:        %265 = arith.index_cast %264 : index to i64
//CHECK-NEXT:        %266 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %267 = "llvm.insertvalue"(%266, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %268 = "llvm.insertvalue"(%267, %265) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %269 = arith.constant 61 : i32
//CHECK-NEXT:        %270 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %269, %270[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%263, %268, %270) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %271 = arith.constant 20 : i32
//CHECK-NEXT:        %272 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %271, %272[] : memref<i32>
//CHECK-NEXT:        %273 = arith.constant 2.000000e+01 : f32
//CHECK-NEXT:        %274 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %273, %274[] : memref<f32>
//CHECK-NEXT:        func.call @_QMarrays_testPmodify_array_one(%1, %272, %274) : (memref<100xf32>, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %275 = "memref.cast"(%2) : (memref<100xf32>) -> memref<?xf32>
//CHECK-NEXT:        %276 = arith.constant 50 : i32
//CHECK-NEXT:        %277 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %276, %277[] : memref<i32>
//CHECK-NEXT:        %278 = arith.constant 5.000000e+01 : f32
//CHECK-NEXT:        %279 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %278, %279[] : memref<f32>
//CHECK-NEXT:        func.call @_QMarrays_testPmodify_array_two(%275, %277, %279) : (memref<?xf32>, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %280 = "memref.cast"(%0) : (memref<100xf32>) -> memref<?xf32>
//CHECK-NEXT:        %281 = arith.constant 70 : i32
//CHECK-NEXT:        %282 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %281, %282[] : memref<i32>
//CHECK-NEXT:        %283 = arith.constant 7.000000e+02 : f32
//CHECK-NEXT:        %284 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %283, %284[] : memref<f32>
//CHECK-NEXT:        func.call @_QMarrays_testPmodify_array_two(%280, %282, %284) : (memref<?xf32>, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %285 = scf.for %286 = %12 to %158 step %15 iter_args(%287 = %16) -> (i32) {
//CHECK-NEXT:        memref.store %287, %4[] : memref<i32>
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %288 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %289 = arith.extui %288 : i32 to i64
//CHECK-NEXT:          %290 = arith.index_cast %289 : i64 to index
//CHECK-NEXT:          %291 = arith.subi %290, %15 : index
//CHECK-NEXT:          %292 = memref.load %1[%291] : memref<100xf32>
//CHECK-NEXT:          %293 = arith.sitofp %288 : i32 to f32
//CHECK-NEXT:          %294 = arith.cmpf oeq, %292, %293 : f32
//CHECK-NEXT:          %295 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %294, %295[] : memref<i1>
//CHECK-NEXT:          %296 = arith.constant {{.*}} : index
//CHECK-NEXT:          %297 = arith.index_cast %296 : index to i64
//CHECK-NEXT:          %298 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %299 = "llvm.insertvalue"(%298, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %300 = "llvm.insertvalue"(%299, %297) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %301 = arith.constant 69 : i32
//CHECK-NEXT:          %302 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %301, %302[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%295, %300, %302) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %303 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %304 = arith.extui %303 : i32 to i64
//CHECK-NEXT:          %305 = arith.index_cast %304 : i64 to index
//CHECK-NEXT:          %306 = arith.subi %305, %15 : index
//CHECK-NEXT:          %307 = memref.load %2[%306] : memref<100xf32>
//CHECK-NEXT:          %308 = arith.subi %156, %303 : i32
//CHECK-NEXT:          %309 = arith.sitofp %308 : i32 to f32
//CHECK-NEXT:          %310 = arith.cmpf oeq, %307, %309 : f32
//CHECK-NEXT:          %311 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %310, %311[] : memref<i1>
//CHECK-NEXT:          %312 = arith.constant {{.*}} : index
//CHECK-NEXT:          %313 = arith.index_cast %312 : index to i64
//CHECK-NEXT:          %314 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %315 = "llvm.insertvalue"(%314, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %316 = "llvm.insertvalue"(%315, %313) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %317 = arith.constant 70 : i32
//CHECK-NEXT:          %318 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %317, %318[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%311, %316, %318) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %319 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %320 = arith.extui %319 : i32 to i64
//CHECK-NEXT:          %321 = arith.index_cast %320 : i64 to index
//CHECK-NEXT:          %322 = arith.subi %321, %15 : index
//CHECK-NEXT:          %323 = memref.load %0[%322] : memref<100xf32>
//CHECK-NEXT:          %324 = arith.muli %319, %13 : i32
//CHECK-NEXT:          %325 = arith.sitofp %324 : i32 to f32
//CHECK-NEXT:          %326 = arith.cmpf oeq, %323, %325 : f32
//CHECK-NEXT:          %327 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %326, %327[] : memref<i1>
//CHECK-NEXT:          %328 = arith.constant {{.*}} : index
//CHECK-NEXT:          %329 = arith.index_cast %328 : index to i64
//CHECK-NEXT:          %330 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %331 = "llvm.insertvalue"(%330, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %332 = "llvm.insertvalue"(%331, %329) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %333 = arith.constant 71 : i32
//CHECK-NEXT:          %334 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %333, %334[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%327, %332, %334) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %335 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %336 = arith.index_cast %15 : index to i32
//CHECK-NEXT:        %337 = arith.addi %335, %336 : i32
//CHECK-NEXT:        scf.yield %337 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %285, %4[] : memref<i32>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %338 = arith.constant 60 : i32
//CHECK-NEXT:        %339 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %338, %339[] : memref<i32>
//CHECK-NEXT:        %340 = arith.constant 1.234000e+02 : f32
//CHECK-NEXT:        %341 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<f32>
//CHECK-NEXT:        memref.store %340, %341[] : memref<f32>
//CHECK-NEXT:        func.call @_QMarrays_testPmodify_array_one(%0, %339, %341) : (memref<100xf32>, memref<i32>, memref<f32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %342 = arith.constant 59 : index
//CHECK-NEXT:        %343 = memref.load %0[%342] : memref<100xf32>
//CHECK-NEXT:        %344 = arith.constant 1.234000e+02 : f32
//CHECK-NEXT:        %345 = arith.cmpf oeq, %343, %344 : f32
//CHECK-NEXT:        %346 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %345, %346[] : memref<i1>
//CHECK-NEXT:        %347 = arith.constant {{.*}} : index
//CHECK-NEXT:        %348 = arith.index_cast %347 : index to i64
//CHECK-NEXT:        %349 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %350 = "llvm.insertvalue"(%349, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %351 = "llvm.insertvalue"(%350, %348) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %352 = arith.constant 75 : i32
//CHECK-NEXT:        %353 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %352, %353[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%346, %351, %353) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      %354 = arith.constant 6.000000e+02 : f32
//CHECK-NEXT:      %355 = arith.constant 59 : index
//CHECK-NEXT:      memref.store %354, %0[%355] : memref<100xf32>
//CHECK-NEXT:      "memref.copy"(%2, %1) : (memref<100xf32>, memref<100xf32>) -> ()
//CHECK-NEXT:      "memref.copy"(%0, %2) : (memref<100xf32>, memref<100xf32>) -> ()
//CHECK-NEXT:      %356 = scf.for %357 = %12 to %158 step %15 iter_args(%358 = %16) -> (i32) {
//CHECK-NEXT:        memref.store %358, %4[] : memref<i32>
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %359 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %360 = arith.extui %359 : i32 to i64
//CHECK-NEXT:          %361 = arith.index_cast %360 : i64 to index
//CHECK-NEXT:          %362 = arith.subi %361, %15 : index
//CHECK-NEXT:          %363 = memref.load %1[%362] : memref<100xf32>
//CHECK-NEXT:          %364 = arith.subi %156, %359 : i32
//CHECK-NEXT:          %365 = arith.sitofp %364 : i32 to f32
//CHECK-NEXT:          %366 = arith.cmpf oeq, %363, %365 : f32
//CHECK-NEXT:          %367 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %366, %367[] : memref<i1>
//CHECK-NEXT:          %368 = arith.constant {{.*}} : index
//CHECK-NEXT:          %369 = arith.index_cast %368 : index to i64
//CHECK-NEXT:          %370 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %371 = "llvm.insertvalue"(%370, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %372 = "llvm.insertvalue"(%371, %369) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %373 = arith.constant 84 : i32
//CHECK-NEXT:          %374 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %373, %374[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%367, %372, %374) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        "memref.alloca_scope"() ({
//CHECK-NEXT:          %375 = memref.load %4[] : memref<i32>
//CHECK-NEXT:          %376 = arith.extui %375 : i32 to i64
//CHECK-NEXT:          %377 = arith.index_cast %376 : i64 to index
//CHECK-NEXT:          %378 = arith.subi %377, %15 : index
//CHECK-NEXT:          %379 = memref.load %2[%378] : memref<100xf32>
//CHECK-NEXT:          %380 = arith.muli %375, %13 : i32
//CHECK-NEXT:          %381 = arith.sitofp %380 : i32 to f32
//CHECK-NEXT:          %382 = arith.cmpf oeq, %379, %381 : f32
//CHECK-NEXT:          %383 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:          memref.store %382, %383[] : memref<i1>
//CHECK-NEXT:          %384 = arith.constant {{.*}} : index
//CHECK-NEXT:          %385 = arith.index_cast %384 : index to i64
//CHECK-NEXT:          %386 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %387 = "llvm.insertvalue"(%386, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %388 = "llvm.insertvalue"(%387, %385) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:          %389 = arith.constant 85 : i32
//CHECK-NEXT:          %390 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:          memref.store %389, %390[] : memref<i32>
//CHECK-NEXT:          func.call @_QPassert(%383, %388, %390) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:          "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:        }) : () -> ()
//CHECK-NEXT:        %391 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %392 = arith.index_cast %15 : index to i32
//CHECK-NEXT:        %393 = arith.addi %391, %392 : i32
//CHECK-NEXT:        scf.yield %393 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %356, %4[] : memref<i32>
//CHECK-NEXT:      %394 = arith.constant 15 : i32
//CHECK-NEXT:      %395 = arith.index_cast %394 : i32 to index
//CHECK-NEXT:      %396 = arith.addi %395, %15 : index
//CHECK-NEXT:      %397 = arith.constant 5 : i32
//CHECK-NEXT:      %398 = scf.for %399 = %12 to %396 step %15 iter_args(%400 = %16) -> (i32) {
//CHECK-NEXT:        memref.store %400, %4[] : memref<i32>
//CHECK-NEXT:        %401 = arith.index_cast %397 : i32 to index
//CHECK-NEXT:        %402 = arith.addi %401, %15 : index
//CHECK-NEXT:        %403 = scf.for %404 = %12 to %402 step %15 iter_args(%405 = %16) -> (i32) {
//CHECK-NEXT:          memref.store %405, %5[] : memref<i32>
//CHECK-NEXT:          %406 = scf.for %407 = %12 to %17 step %15 iter_args(%408 = %16) -> (i32) {
//CHECK-NEXT:            memref.store %408, %6[] : memref<i32>
//CHECK-NEXT:            %409 = memref.load %6[] : memref<i32>
//CHECK-NEXT:            %410 = memref.load %5[] : memref<i32>
//CHECK-NEXT:            %411 = arith.muli %410, %13 : i32
//CHECK-NEXT:            %412 = arith.addi %409, %411 : i32
//CHECK-NEXT:            %413 = memref.load %4[] : memref<i32>
//CHECK-NEXT:            %414 = arith.muli %413, %156 : i32
//CHECK-NEXT:            %415 = arith.addi %412, %414 : i32
//CHECK-NEXT:            %416 = arith.extui %409 : i32 to i64
//CHECK-NEXT:            %417 = arith.index_cast %416 : i64 to index
//CHECK-NEXT:            %418 = arith.subi %417, %15 : index
//CHECK-NEXT:            %419 = arith.extui %410 : i32 to i64
//CHECK-NEXT:            %420 = arith.index_cast %419 : i64 to index
//CHECK-NEXT:            %421 = arith.subi %420, %15 : index
//CHECK-NEXT:            %422 = arith.extui %413 : i32 to i64
//CHECK-NEXT:            %423 = arith.index_cast %422 : i64 to index
//CHECK-NEXT:            %424 = arith.subi %423, %15 : index
//CHECK-NEXT:            memref.store %415, %3[%424, %421, %418] : memref<15x5x10xi32>
//CHECK-NEXT:            %425 = memref.load %6[] : memref<i32>
//CHECK-NEXT:            %426 = arith.index_cast %15 : index to i32
//CHECK-NEXT:            %427 = arith.addi %425, %426 : i32
//CHECK-NEXT:            scf.yield %427 : i32
//CHECK-NEXT:          }
//CHECK-NEXT:          memref.store %406, %6[] : memref<i32>
//CHECK-NEXT:          %428 = memref.load %5[] : memref<i32>
//CHECK-NEXT:          %429 = arith.index_cast %15 : index to i32
//CHECK-NEXT:          %430 = arith.addi %428, %429 : i32
//CHECK-NEXT:          scf.yield %430 : i32
//CHECK-NEXT:        }
//CHECK-NEXT:        memref.store %403, %5[] : memref<i32>
//CHECK-NEXT:        %431 = memref.load %4[] : memref<i32>
//CHECK-NEXT:        %432 = arith.index_cast %15 : index to i32
//CHECK-NEXT:        %433 = arith.addi %431, %432 : i32
//CHECK-NEXT:        scf.yield %433 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %398, %4[] : memref<i32>
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %434 = arith.constant 2 : index
//CHECK-NEXT:        %435 = arith.constant 3 : index
//CHECK-NEXT:        %436 = arith.constant 4 : index
//CHECK-NEXT:        %437 = memref.load %3[%436, %435, %434] : memref<15x5x10xi32>
//CHECK-NEXT:        %438 = arith.constant 543 : i32
//CHECK-NEXT:        %439 = arith.cmpi eq, %437, %438 : i32
//CHECK-NEXT:        %440 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %439, %440[] : memref<i1>
//CHECK-NEXT:        %441 = arith.constant {{.*}} : index
//CHECK-NEXT:        %442 = arith.index_cast %441 : index to i64
//CHECK-NEXT:        %443 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %444 = "llvm.insertvalue"(%443, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %445 = "llvm.insertvalue"(%444, %442) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %446 = arith.constant 96 : i32
//CHECK-NEXT:        %447 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %446, %447[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%440, %445, %447) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %448 = arith.constant 7 : index
//CHECK-NEXT:        %449 = arith.constant 4 : index
//CHECK-NEXT:        %450 = arith.constant 14 : index
//CHECK-NEXT:        %451 = memref.load %3[%450, %449, %448] : memref<15x5x10xi32>
//CHECK-NEXT:        %452 = arith.constant 1558 : i32
//CHECK-NEXT:        %453 = arith.cmpi eq, %451, %452 : i32
//CHECK-NEXT:        %454 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %453, %454[] : memref<i1>
//CHECK-NEXT:        %455 = arith.constant {{.*}} : index
//CHECK-NEXT:        %456 = arith.index_cast %455 : index to i64
//CHECK-NEXT:        %457 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %458 = "llvm.insertvalue"(%457, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %459 = "llvm.insertvalue"(%458, %456) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %460 = arith.constant 97 : i32
//CHECK-NEXT:        %461 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %460, %461[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%454, %459, %461) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %462 = "memref.cast"(%3) : (memref<15x5x10xi32>) -> memref<?x?x?xi32>
//CHECK-NEXT:        %463 = arith.constant 2 : i32
//CHECK-NEXT:        %464 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %463, %464[] : memref<i32>
//CHECK-NEXT:        %465 = arith.constant 3 : i32
//CHECK-NEXT:        %466 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %465, %466[] : memref<i32>
//CHECK-NEXT:        %467 = arith.constant 4 : i32
//CHECK-NEXT:        %468 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %467, %468[] : memref<i32>
//CHECK-NEXT:        %469 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %156, %469[] : memref<i32>
//CHECK-NEXT:        func.call @_QMarrays_testPmodify_3darray_one(%462, %464, %466, %468, %469) : (memref<?x?x?xi32>, memref<i32>, memref<i32>, memref<i32>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %470 = arith.constant 2 : index
//CHECK-NEXT:        %471 = arith.constant 3 : index
//CHECK-NEXT:        %472 = memref.load %3[%471, %470, %15] : memref<15x5x10xi32>
//CHECK-NEXT:        %473 = arith.cmpi eq, %472, %156 : i32
//CHECK-NEXT:        %474 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %473, %474[] : memref<i1>
//CHECK-NEXT:        %475 = arith.constant {{.*}} : index
//CHECK-NEXT:        %476 = arith.index_cast %475 : index to i64
//CHECK-NEXT:        %477 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %478 = "llvm.insertvalue"(%477, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %479 = "llvm.insertvalue"(%478, %476) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %480 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %156, %480[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%474, %479, %480) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %481 = arith.constant 6 : i32
//CHECK-NEXT:        %482 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %481, %482[] : memref<i32>
//CHECK-NEXT:        %483 = arith.constant 2 : i32
//CHECK-NEXT:        %484 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %483, %484[] : memref<i32>
//CHECK-NEXT:        %485 = arith.constant 12 : i32
//CHECK-NEXT:        %486 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %485, %486[] : memref<i32>
//CHECK-NEXT:        %487 = arith.constant 200 : i32
//CHECK-NEXT:        %488 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %487, %488[] : memref<i32>
//CHECK-NEXT:        func.call @_QMarrays_testPmodify_3darray_two(%3, %482, %484, %486, %488) : (memref<15x5x10xi32>, memref<i32>, memref<i32>, memref<i32>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        %489 = arith.constant 5 : index
//CHECK-NEXT:        %490 = arith.constant 11 : index
//CHECK-NEXT:        %491 = memref.load %3[%490, %15, %489] : memref<15x5x10xi32>
//CHECK-NEXT:        %492 = arith.constant 200 : i32
//CHECK-NEXT:        %493 = arith.cmpi eq, %491, %492 : i32
//CHECK-NEXT:        %494 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
//CHECK-NEXT:        memref.store %493, %494[] : memref<i1>
//CHECK-NEXT:        %495 = arith.constant {{.*}} : index
//CHECK-NEXT:        %496 = arith.index_cast %495 : index to i64
//CHECK-NEXT:        %497 = "llvm.mlir.undef"() : () -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %498 = "llvm.insertvalue"(%497, %56) <{position = array<i64: 0>}> : (!llvm.struct<(!llvm.ptr, i64)>, !llvm.ptr) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %499 = "llvm.insertvalue"(%498, %496) <{position = array<i64: 1>}> : (!llvm.struct<(!llvm.ptr, i64)>, i64) -> !llvm.struct<(!llvm.ptr, i64)>
//CHECK-NEXT:        %500 = arith.constant 102 : i32
//CHECK-NEXT:        %501 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:        memref.store %500, %501[] : memref<i32>
//CHECK-NEXT:        func.call @_QPassert(%494, %499, %501) : (memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMarrays_testPmodify_array_one(%0 : memref<100xf32> {fir.bindc_name = "a"}, %1 : memref<i32> {fir.bindc_name = "idx"}, %2 : memref<f32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %3 = memref.load %2[] : memref<f32>
//CHECK-NEXT:      %4 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %5 = arith.extui %4 : i32 to i64
//CHECK-NEXT:      %6 = arith.index_cast %5 : i64 to index
//CHECK-NEXT:      %7 = arith.constant 1 : index
//CHECK-NEXT:      %8 = arith.subi %6, %7 : index
//CHECK-NEXT:      memref.store %3, %0[%8] : memref<100xf32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMarrays_testPmodify_array_two(%0 : memref<?xf32> {fir.bindc_name = "a"}, %1 : memref<i32> {fir.bindc_name = "idx"}, %2 : memref<f32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %3 = memref.load %2[] : memref<f32>
//CHECK-NEXT:      %4 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %5 = arith.extui %4 : i32 to i64
//CHECK-NEXT:      %6 = arith.index_cast %5 : i64 to index
//CHECK-NEXT:      %7 = arith.constant 1 : index
//CHECK-NEXT:      %8 = arith.subi %6, %7 : index
//CHECK-NEXT:      memref.store %3, %0[%8] : memref<?xf32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMarrays_testPmodify_3darray_one(%0 : memref<?x?x?xi32> {fir.bindc_name = "array"}, %1 : memref<i32> {fir.bindc_name = "k"}, %2 : memref<i32> {fir.bindc_name = "j"}, %3 : memref<i32> {fir.bindc_name = "i"}, %4 : memref<i32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %5 = memref.load %4[] : memref<i32>
//CHECK-NEXT:      %6 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %7 = arith.extui %6 : i32 to i64
//CHECK-NEXT:      %8 = arith.index_cast %7 : i64 to index
//CHECK-NEXT:      %9 = arith.constant 1 : index
//CHECK-NEXT:      %10 = arith.subi %8, %9 : index
//CHECK-NEXT:      %11 = memref.load %2[] : memref<i32>
//CHECK-NEXT:      %12 = arith.extui %11 : i32 to i64
//CHECK-NEXT:      %13 = arith.index_cast %12 : i64 to index
//CHECK-NEXT:      %14 = arith.subi %13, %9 : index
//CHECK-NEXT:      %15 = memref.load %3[] : memref<i32>
//CHECK-NEXT:      %16 = arith.extui %15 : i32 to i64
//CHECK-NEXT:      %17 = arith.index_cast %16 : i64 to index
//CHECK-NEXT:      %18 = arith.subi %17, %9 : index
//CHECK-NEXT:      memref.store %5, %0[%18, %14, %10] : memref<?x?x?xi32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QMarrays_testPmodify_3darray_two(%0 : memref<15x5x10xi32> {fir.bindc_name = "array"}, %1 : memref<i32> {fir.bindc_name = "k"}, %2 : memref<i32> {fir.bindc_name = "j"}, %3 : memref<i32> {fir.bindc_name = "i"}, %4 : memref<i32> {fir.bindc_name = "value"}) {
//CHECK-NEXT:      %5 = memref.load %4[] : memref<i32>
//CHECK-NEXT:      %6 = memref.load %1[] : memref<i32>
//CHECK-NEXT:      %7 = arith.extui %6 : i32 to i64
//CHECK-NEXT:      %8 = arith.index_cast %7 : i64 to index
//CHECK-NEXT:      %9 = arith.constant 1 : index
//CHECK-NEXT:      %10 = arith.subi %8, %9 : index
//CHECK-NEXT:      %11 = memref.load %2[] : memref<i32>
//CHECK-NEXT:      %12 = arith.extui %11 : i32 to i64
//CHECK-NEXT:      %13 = arith.index_cast %12 : i64 to index
//CHECK-NEXT:      %14 = arith.subi %13, %9 : index
//CHECK-NEXT:      %15 = memref.load %3[] : memref<i32>
//CHECK-NEXT:      %16 = arith.extui %15 : i32 to i64
//CHECK-NEXT:      %17 = arith.index_cast %16 : i64 to index
//CHECK-NEXT:      %18 = arith.subi %17, %9 : index
//CHECK-NEXT:      memref.store %5, %0[%18, %14, %10] : memref<15x5x10xi32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    "memref.global"() <{sym_name = "_QQro.10xr4.0", type = memref<10xf32>, initial_value = dense<[1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00, 7.000000e+00, 8.000000e+00, 9.000000e+00, 1.000000e+01]> : tensor<10xf32>, sym_visibility = "private", constant}> : () -> ()
//CHECK-NEXT:    "memref.global"() <{sym_name = "_QQro.10xr4.1", type = memref<10xf32>, initial_value = dense<[1.100000e+01, 1.200000e+01, 1.300000e+01, 1.400000e+01, 1.500000e+01, 1.600000e+01, 1.700000e+01, 1.800000e+01, 1.900000e+01, 2.000000e+01]> : tensor<10xf32>, sym_visibility = "private", constant}> : () -> ()
//CHECK-NEXT:    func.func private @_QPassert(memref<i1>, !llvm.struct<(!llvm.ptr, i64)>, memref<i32>) -> () 
//CHECK-NEXT:    "llvm.mlir.global"() <{global_type = !llvm.array<{{[0-9]+}} x i8>, sym_name = "_{{.*}}", linkage = #llvm.linkage<"internal">, addr_space = 0 : i32, constant, value = "{{.*}}", unnamed_addr = 0 : i64}> ({
//CHECK-NEXT:    }) : () -> ()
//CHECK-NEXT:  }
//CHECK-EMPTY:  
