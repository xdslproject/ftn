// RUN: xftn %S/../../../../examples/solvers/gauss_seidel_stack.F90 --stdout -t %S/tmp --cleanup --stages=flang,pre,ftn -v0 | FileCheck %s 
//CHECK:       builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.ident = "flang version 20.1.7 (https://github.com/llvm/llvm-project 6146a88f60492b520a36f8f8f3231e15f3cc6082)", llvm.target_triple = "x86_64-unknown-linux-gnu"} {
//CHECK-NEXT:    func.func @_QMgauss_seidel_stack_modPmain() {
//CHECK-NEXT:      %0 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<256x256xf32>
//CHECK-NEXT:      %1 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %2 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %3 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i32>
//CHECK-NEXT:      %4 = arith.constant 1 : i32
//CHECK-NEXT:      %5 = arith.index_cast %4 : i32 to index
//CHECK-NEXT:      %6 = arith.constant 1000 : i32
//CHECK-NEXT:      %7 = arith.index_cast %6 : i32 to index
//CHECK-NEXT:      %8 = arith.constant 1 : i32
//CHECK-NEXT:      %9 = arith.index_cast %8 : i32 to index
//CHECK-NEXT:      %10 = arith.index_cast %5 : index to i32
//CHECK-NEXT:      %11 = arith.constant 1 : index
//CHECK-NEXT:      %12 = arith.addi %7, %11 : index
//CHECK-NEXT:      %13 = scf.for %14 = %5 to %12 step %9 iter_args(%15 = %10) -> (i32) {
//CHECK-NEXT:        memref.store %15, %3[] : memref<i32>
//CHECK-NEXT:        %16 = arith.constant 2 : i32
//CHECK-NEXT:        %17 = arith.index_cast %16 : i32 to index
//CHECK-NEXT:        %18 = arith.constant 255 : i32
//CHECK-NEXT:        %19 = arith.index_cast %18 : i32 to index
//CHECK-NEXT:        %20 = arith.constant 1 : i32
//CHECK-NEXT:        %21 = arith.index_cast %20 : i32 to index
//CHECK-NEXT:        %22 = arith.index_cast %17 : index to i32
//CHECK-NEXT:        %23 = arith.constant 1 : index
//CHECK-NEXT:        %24 = arith.addi %19, %23 : index
//CHECK-NEXT:        %25 = scf.for %26 = %17 to %24 step %21 iter_args(%27 = %22) -> (i32) {
//CHECK-NEXT:          memref.store %27, %1[] : memref<i32>
//CHECK-NEXT:          %28 = arith.constant 2 : i32
//CHECK-NEXT:          %29 = arith.index_cast %28 : i32 to index
//CHECK-NEXT:          %30 = arith.constant 255 : i32
//CHECK-NEXT:          %31 = arith.index_cast %30 : i32 to index
//CHECK-NEXT:          %32 = arith.constant 1 : i32
//CHECK-NEXT:          %33 = arith.index_cast %32 : i32 to index
//CHECK-NEXT:          %34 = arith.index_cast %29 : index to i32
//CHECK-NEXT:          %35 = arith.constant 1 : index
//CHECK-NEXT:          %36 = arith.addi %31, %35 : index
//CHECK-NEXT:          %37 = scf.for %38 = %29 to %36 step %33 iter_args(%39 = %34) -> (i32) {
//CHECK-NEXT:            memref.store %39, %2[] : memref<i32>
//CHECK-NEXT:            %40 = memref.load %2[] : memref<i32>
//CHECK-NEXT:            %41 = arith.extui %40 : i32 to i64
//CHECK-NEXT:            %42 = arith.index_cast %41 : i64 to index
//CHECK-NEXT:            %43 = arith.constant 1 : index
//CHECK-NEXT:            %44 = arith.subi %42, %43 : index
//CHECK-NEXT:            %45 = memref.load %1[] : memref<i32>
//CHECK-NEXT:            %46 = arith.constant 1 : i32
//CHECK-NEXT:            %47 = arith.subi %45, %46 : i32
//CHECK-NEXT:            %48 = arith.extui %47 : i32 to i64
//CHECK-NEXT:            %49 = arith.index_cast %48 : i64 to index
//CHECK-NEXT:            %50 = arith.constant 1 : index
//CHECK-NEXT:            %51 = arith.subi %49, %50 : index
//CHECK-NEXT:            %52 = memref.load %0[%51, %44] : memref<256x256xf32>
//CHECK-NEXT:            %53 = memref.load %2[] : memref<i32>
//CHECK-NEXT:            %54 = arith.extui %53 : i32 to i64
//CHECK-NEXT:            %55 = arith.index_cast %54 : i64 to index
//CHECK-NEXT:            %56 = arith.constant 1 : index
//CHECK-NEXT:            %57 = arith.subi %55, %56 : index
//CHECK-NEXT:            %58 = memref.load %1[] : memref<i32>
//CHECK-NEXT:            %59 = arith.constant 1 : i32
//CHECK-NEXT:            %60 = arith.addi %58, %59 : i32
//CHECK-NEXT:            %61 = arith.extui %60 : i32 to i64
//CHECK-NEXT:            %62 = arith.index_cast %61 : i64 to index
//CHECK-NEXT:            %63 = arith.constant 1 : index
//CHECK-NEXT:            %64 = arith.subi %62, %63 : index
//CHECK-NEXT:            %65 = memref.load %0[%64, %57] : memref<256x256xf32>
//CHECK-NEXT:            %66 = arith.addf %52, %65 fastmath<contract> : f32
//CHECK-NEXT:            %67 = memref.load %2[] : memref<i32>
//CHECK-NEXT:            %68 = arith.constant 1 : i32
//CHECK-NEXT:            %69 = arith.subi %67, %68 : i32
//CHECK-NEXT:            %70 = arith.extui %69 : i32 to i64
//CHECK-NEXT:            %71 = arith.index_cast %70 : i64 to index
//CHECK-NEXT:            %72 = arith.constant 1 : index
//CHECK-NEXT:            %73 = arith.subi %71, %72 : index
//CHECK-NEXT:            %74 = memref.load %1[] : memref<i32>
//CHECK-NEXT:            %75 = arith.extui %74 : i32 to i64
//CHECK-NEXT:            %76 = arith.index_cast %75 : i64 to index
//CHECK-NEXT:            %77 = arith.constant 1 : index
//CHECK-NEXT:            %78 = arith.subi %76, %77 : index
//CHECK-NEXT:            %79 = memref.load %0[%78, %73] : memref<256x256xf32>
//CHECK-NEXT:            %80 = arith.addf %66, %79 fastmath<contract> : f32
//CHECK-NEXT:            %81 = memref.load %2[] : memref<i32>
//CHECK-NEXT:            %82 = arith.constant 1 : i32
//CHECK-NEXT:            %83 = arith.addi %81, %82 : i32
//CHECK-NEXT:            %84 = arith.extui %83 : i32 to i64
//CHECK-NEXT:            %85 = arith.index_cast %84 : i64 to index
//CHECK-NEXT:            %86 = arith.constant 1 : index
//CHECK-NEXT:            %87 = arith.subi %85, %86 : index
//CHECK-NEXT:            %88 = memref.load %1[] : memref<i32>
//CHECK-NEXT:            %89 = arith.extui %88 : i32 to i64
//CHECK-NEXT:            %90 = arith.index_cast %89 : i64 to index
//CHECK-NEXT:            %91 = arith.constant 1 : index
//CHECK-NEXT:            %92 = arith.subi %90, %91 : index
//CHECK-NEXT:            %93 = memref.load %0[%92, %87] : memref<256x256xf32>
//CHECK-NEXT:            %94 = arith.addf %80, %93 fastmath<contract> : f32
//CHECK-NEXT:            %95 = arith.constant 2.500000e-01 : f32
//CHECK-NEXT:            %96 = arith.mulf %94, %95 fastmath<contract> : f32
//CHECK-NEXT:            %97 = memref.load %2[] : memref<i32>
//CHECK-NEXT:            %98 = arith.extui %97 : i32 to i64
//CHECK-NEXT:            %99 = arith.index_cast %98 : i64 to index
//CHECK-NEXT:            %100 = arith.constant 1 : index
//CHECK-NEXT:            %101 = arith.subi %99, %100 : index
//CHECK-NEXT:            %102 = memref.load %1[] : memref<i32>
//CHECK-NEXT:            %103 = arith.extui %102 : i32 to i64
//CHECK-NEXT:            %104 = arith.index_cast %103 : i64 to index
//CHECK-NEXT:            %105 = arith.constant 1 : index
//CHECK-NEXT:            %106 = arith.subi %104, %105 : index
//CHECK-NEXT:            memref.store %96, %0[%106, %101] : memref<256x256xf32>
//CHECK-NEXT:            %107 = arith.addi %38, %33 : index
//CHECK-NEXT:            %108 = memref.load %2[] : memref<i32>
//CHECK-NEXT:            %109 = arith.index_cast %33 : index to i32
//CHECK-NEXT:            %110 = arith.addi %108, %109 : i32
//CHECK-NEXT:            scf.yield %110 : i32
//CHECK-NEXT:          }
//CHECK-NEXT:          memref.store %37, %2[] : memref<i32>
//CHECK-NEXT:          %111 = arith.addi %26, %21 : index
//CHECK-NEXT:          %112 = memref.load %1[] : memref<i32>
//CHECK-NEXT:          %113 = arith.index_cast %21 : index to i32
//CHECK-NEXT:          %114 = arith.addi %112, %113 : i32
//CHECK-NEXT:          scf.yield %114 : i32
//CHECK-NEXT:        }
//CHECK-NEXT:        memref.store %25, %1[] : memref<i32>
//CHECK-NEXT:        %115 = arith.addi %14, %9 : index
//CHECK-NEXT:        %116 = memref.load %3[] : memref<i32>
//CHECK-NEXT:        %117 = arith.index_cast %9 : index to i32
//CHECK-NEXT:        %118 = arith.addi %116, %117 : i32
//CHECK-NEXT:        scf.yield %118 : i32
//CHECK-NEXT:      }
//CHECK-NEXT:      memref.store %13, %3[] : memref<i32>
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func @_QQmain() {
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        func.call @_QMgauss_seidel_stack_modPmain() : () -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      func.return
//CHECK-NEXT:    }
//CHECK-NEXT:    func.func private @_FortranAProgramStart(i32, !llvm.ptr, !llvm.ptr, !llvm.ptr) -> () 
//CHECK-NEXT:    func.func private @_FortranAProgramEndStatement() -> () 
//CHECK-NEXT:    func.func @main(%0 : i32, %1 : !llvm.ptr, %2 : !llvm.ptr) -> i32 {
//CHECK-NEXT:      %3 = memref.alloc() : memref<1xmemref<memref<1xmemref<i8>>>>
//CHECK-NEXT:      %4 = arith.constant 0 : index
//CHECK-NEXT:      %5 = memref.load %3[%4] : memref<1xmemref<memref<1xmemref<i8>>>>
//CHECK-NEXT:      %6 = "memref.extract_aligned_pointer_as_index"(%5) : (memref<memref<1xmemref<i8>>>) -> index
//CHECK-NEXT:      %7 = arith.index_cast %6 : index to i64
//CHECK-NEXT:      %8 = "llvm.inttoptr"(%7) : (i64) -> !llvm.ptr
//CHECK-NEXT:      func.call @_FortranAProgramStart(%0, %1, %2, %8) : (i32, !llvm.ptr, !llvm.ptr, !llvm.ptr) -> ()
//CHECK-NEXT:      "memref.alloca_scope"() ({
//CHECK-NEXT:        func.call @_QQmain() : () -> ()
//CHECK-NEXT:        "memref.alloca_scope.return"() : () -> ()
//CHECK-NEXT:      }) : () -> ()
//CHECK-NEXT:      func.call @_FortranAProgramEndStatement() : () -> ()
//CHECK-NEXT:      %9 = arith.constant 0 : i32
//CHECK-NEXT:      func.return %9 : i32
//CHECK-NEXT:    }
//CHECK-NEXT:  }
//CHECK-EMPTY:  
